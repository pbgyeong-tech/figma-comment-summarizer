<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comment Summarizer</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 12px;
      color: #333;
      background-color: #fff;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* ===== Header ===== */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #e5e5e5;
      background-color: #fafafa;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .logo-icon {
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, #18a0fb 0%, #0d8de5 100%);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      font-weight: 600;
    }

    .logo-text {
      font-size: 13px;
      font-weight: 600;
      color: #1a1a1a;
    }

    .date-picker {
      position: relative;
    }

    .date-select {
      padding: 6px 28px 6px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 11px;
      font-family: 'Inter', sans-serif;
      background-color: #fff;
      color: #333;
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23666' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
    }

    .date-select:focus {
      outline: none;
      border-color: #18a0fb;
    }

    /* ===== Tabs ===== */
    .tabs {
      display: flex;
      border-bottom: 1px solid #e5e5e5;
      background-color: #fff;
    }

    .tab {
      flex: 1;
      padding: 10px 16px;
      font-size: 11px;
      font-weight: 500;
      color: #666;
      background: none;
      border: none;
      cursor: pointer;
      position: relative;
      transition: color 0.2s;
    }

    .tab:hover {
      color: #333;
    }

    .tab.active {
      color: #18a0fb;
    }

    .tab.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      right: 0;
      height: 2px;
      background-color: #18a0fb;
    }

    .tab-count {
      display: inline-block;
      margin-left: 4px;
      padding: 2px 6px;
      background-color: #f0f0f0;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 500;
      color: #666;
    }

    .tab.active .tab-count {
      background-color: #e3f2fd;
      color: #18a0fb;
    }

    /* ===== Content Area ===== */
    .content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #999;
      text-align: center;
    }

    .empty-icon {
      width: 48px;
      height: 48px;
      background-color: #f5f5f5;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 12px;
    }

    .empty-icon svg {
      width: 24px;
      height: 24px;
      stroke: #ccc;
    }

    .empty-title {
      font-size: 13px;
      font-weight: 500;
      color: #666;
      margin-bottom: 4px;
    }

    .empty-desc {
      font-size: 11px;
      color: #999;
    }

    /* ===== Comment List (placeholder) ===== */
    .comment-list {
      display: none;
    }

    .comment-group {
      margin-bottom: 16px;
    }

    .group-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 0;
      font-size: 12px;
      font-weight: 600;
      color: #333;
    }

    .group-icon {
      font-size: 14px;
    }

    .comment-item {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 12px;
      background-color: #fafafa;
      border-radius: 8px;
      margin-bottom: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .comment-item:hover {
      background-color: #f0f0f0;
    }


    .comment-content {
      flex: 1;
    }

    .comment-tag {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
      margin-bottom: 4px;
    }

    .tag-bug {
      background-color: #ffebee;
      color: #e53935;
    }

    .tag-change {
      background-color: #fff3e0;
      color: #fb8c00;
    }

    .tag-question {
      background-color: #e3f2fd;
      color: #1e88e5;
    }

    .tag-feedback {
      background-color: #f5f5f5;
      color: #757575;
    }

    .comment-summary {
      font-size: 12px;
      color: #333;
      line-height: 1.4;
    }

    .comment-meta {
      font-size: 10px;
      color: #999;
      margin-top: 4px;
    }

    /* ===== Footer ===== */
    .footer {
      padding: 12px 16px;
      border-top: 1px solid #e5e5e5;
      background-color: #fafafa;
    }

    .btn-settings {
      width: 100%;
      padding: 10px 16px;
      border: 1px solid #ddd;
      border-radius: 6px;
      background-color: #fff;
      font-size: 11px;
      font-weight: 500;
      font-family: 'Inter', sans-serif;
      color: #666;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .btn-settings:hover {
      border-color: #18a0fb;
      color: #18a0fb;
    }

    .btn-settings svg {
      width: 14px;
      height: 14px;
    }

    /* ===== Modal (API Settings) ===== */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.4);
      z-index: 100;
    }

    .modal-overlay.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal {
      background-color: #fff;
      border-radius: 8px;
      width: 280px;
      max-width: 90%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    }

    .modal-header {
      padding: 16px;
      border-bottom: 1px solid #e5e5e5;
    }

    .modal-title {
      font-size: 14px;
      font-weight: 600;
      color: #1a1a1a;
    }

    .modal-body {
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .input-group label {
      font-size: 11px;
      font-weight: 500;
      color: #666;
    }

    .input-group input {
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 11px;
      font-family: 'Inter', sans-serif;
    }

    .input-group input:focus {
      outline: none;
      border-color: #18a0fb;
    }

    .modal-footer {
      padding: 12px 16px;
      border-top: 1px solid #e5e5e5;
      display: flex;
      gap: 8px;
    }

    .btn {
      flex: 1;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 500;
      font-family: 'Inter', sans-serif;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary {
      background-color: #18a0fb;
      color: white;
      border: none;
    }

    .btn-primary:hover {
      background-color: #0d8de5;
    }

    .btn-secondary {
      background-color: #fff;
      color: #666;
      border: 1px solid #ddd;
    }

    .btn-secondary:hover {
      background-color: #f5f5f5;
    }

    /* ===== Toast Notification ===== */
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background-color: #333;
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
      z-index: 200;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .toast.show {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }

    .toast.success {
      background-color: #4caf50;
    }

    .toast.error {
      background-color: #e53935;
    }

    /* ===== Settings Status Badge ===== */
    .settings-status {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: 6px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
    }

    .settings-status.configured {
      background-color: #e8f5e9;
      color: #4caf50;
    }

    .settings-status.not-configured {
      background-color: #fff3e0;
      color: #fb8c00;
    }

    /* ===== Password Toggle ===== */
    .input-wrapper {
      position: relative;
      display: flex;
      align-items: center;
    }

    .input-wrapper input {
      width: 100%;
      padding-right: 36px;
    }

    .toggle-visibility {
      position: absolute;
      right: 8px;
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      color: #999;
      font-size: 14px;
      line-height: 1;
      transition: color 0.2s;
    }

    .toggle-visibility:hover {
      color: #333;
    }

    /* ===== Spinner Animation ===== */
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    .spinner {
      animation: spin 1s linear infinite;
    }

    /* ===== Smart Summary Card ===== */
    .summary-card {
      background: linear-gradient(135deg, #f0f4ff 0%, #e8f0fe 100%);
      border: 1px solid #d2e3fc;
      border-radius: 8px;
      padding: 10px 12px;
      margin: 6px 12px 4px;
      font-size: 11px;
      line-height: 1.6;
    }

    .summary-card-title {
      font-weight: 600;
      font-size: 12px;
      margin-bottom: 6px;
      color: #1a73e8;
    }

    .summary-card-section {
      margin: 3px 0;
      color: #333;
    }

    .summary-card-section .section-icon {
      margin-right: 4px;
    }

    .summary-card-loading {
      color: #999;
      font-style: italic;
      padding: 8px 12px;
      font-size: 11px;
    }

    /* ===== Frame-Level Header ===== */
    .frame-header {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 10px;
      margin: 8px 0 2px;
      font-size: 11px;
      font-weight: 600;
      color: #444;
      border-bottom: 1px solid #e0e0e0;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }

    .frame-header:hover {
      background: #f5f5f5;
    }

    .frame-header .frame-arrow {
      font-size: 9px;
      transition: transform 0.2s;
      color: #999;
    }

    .frame-header .frame-arrow.open {
      transform: rotate(90deg);
    }

    .frame-header .frame-count {
      margin-left: auto;
      font-weight: 400;
      font-size: 10px;
      color: #999;
    }

    .frame-items-container {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .frame-items-container.frame-collapsed {
      max-height: 0 !important;
    }

    /* ===== Thread Card ===== */
    .thread-card {
      background: #fafafa;
      border-radius: 8px;
      margin: 6px 4px;
      overflow: hidden;
      border: 1px solid #eee;
      transition: border-color 0.2s;
    }

    .thread-card:hover {
      border-color: #ccc;
    }

    .thread-head {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 12px;
      cursor: pointer;
      user-select: none;
    }

    .thread-head .comment-content {
      flex: 1;
    }

    .thread-reply-badge {
      font-size: 10px;
      color: #888;
      margin-top: 4px;
    }

    .thread-replies {
      border-top: 1px solid #eee;
      padding: 0;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .thread-replies.thread-open {
      max-height: 2000px;
    }

    .thread-reply-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 8px 12px 8px 32px;
      background: #f5f5f5;
      border-top: 1px solid #eee;
      font-size: 11px;
    }

    .thread-reply-item .reply-msg {
      color: #555;
      line-height: 1.5;
    }

    .thread-reply-item .reply-meta {
      font-size: 10px;
      color: #999;
      margin-top: 2px;
    }

    .sub-group-header {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 10px;
      margin: 8px 0 2px;
      font-size: 11px;
      font-weight: 600;
      color: #555;
      border-bottom: 1px solid #e0e0e0;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }

    .sub-group-header:hover {
      background: #f5f5f5;
    }

    .sub-group-header .sub-arrow {
      font-size: 9px;
      transition: transform 0.2s;
      color: #999;
    }

    .sub-group-header .sub-arrow.open {
      transform: rotate(90deg);
    }

    .sub-group-header .sub-icon {
      font-size: 12px;
    }

    .sub-group-header .sub-count {
      margin-left: auto;
      font-weight: 400;
      font-size: 10px;
      color: #999;
    }

    .sub-items-container {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .sub-items-container.sub-collapsed {
      max-height: 0 !important;
    }

    /* ===== Accordion Toggle ===== */
    .group-toggle {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 11px;
      color: #666;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
      transition: color 0.2s;
    }

    .group-toggle:hover {
      color: #333;
    }

    .group-toggle .toggle-arrow {
      transition: transform 0.2s;
      font-size: 10px;
    }

    .group-toggle .toggle-arrow.open {
      transform: rotate(90deg);
    }

    .comment-items-container {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .comment-items-container.collapsed {
      max-height: 0 !important;
    }
  </style>
</head>

<body>

  <!-- Header -->
  <header class="header">
    <div class="logo">
      <div class="logo-icon">ğŸ’¬</div>
      <span class="logo-text">Comment Summarizer</span>
    </div>
    <div class="date-picker">
      <select class="date-select" id="dateRange">
        <option value="24h">ìµœê·¼ 24ì‹œê°„</option>
        <option value="3d">ìµœê·¼ 3ì¼</option>
        <option value="1w">ìµœê·¼ 1ì£¼ì¼</option>
        <option value="last">ë§ˆì§€ë§‰ ë°©ë¬¸ ì´í›„</option>
      </select>
    </div>
  </header>

  <!-- Tabs -->
  <div class="tabs">
    <button class="tab active" id="tabAll">
      ì „ì²´ ë³´ê¸° <span class="tab-count">0</span>
    </button>
    <button class="tab" id="tabPending">
      ë¯¸ì™„ë£Œë§Œ <span class="tab-count">0</span>
    </button>
  </div>

  <!-- Content -->
  <main class="content">
    <!-- Empty State -->
    <div class="empty-state" id="emptyState">
      <div class="empty-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
        </svg>
      </div>
      <p class="empty-title">ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤</p>
      <p class="empty-desc">ê¸°ê°„ì„ ì„ íƒí•˜ê³  API í‚¤ë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”</p>
    </div>

    <!-- Comment List (will be populated by JS) -->
    <div class="comment-list" id="commentList">
      <!-- Example structure for reference:
      <div class="comment-group">
        <div class="group-header">
          <span class="group-icon">ğŸ“</span>
          <span>Home í™”ë©´</span>
        </div>
        <div class="comment-item">
          <div class="comment-content">
            <span class="comment-tag tag-change">ìˆ˜ì • ìš”ì²­</span>
            <p class="comment-summary">ë¡œê³  í¬ê¸°ë¥¼ 20% ì¤„ì—¬ì£¼ì„¸ìš”</p>
            <p class="comment-meta">@designer_kim Â· 2ì‹œê°„ ì „</p>
          </div>
        </div>
      </div>
      -->
    </div>
  </main>

  <!-- Footer -->
  <footer class="footer">
    <button class="btn-settings" id="openSettings">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="3"></circle>
        <path
          d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
        </path>
      </svg>
      API í‚¤ ì„¤ì •
      <span class="settings-status not-configured" id="settingsStatus">ë¯¸ì„¤ì •</span>
    </button>
  </footer>

  <!-- Toast Notification -->
  <div class="toast" id="toast"></div>

  <!-- Modal: API Settings -->
  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title">API í‚¤ ì„¤ì •</h2>
      </div>
      <div class="modal-body">
        <div class="input-group">
          <label for="figmaFileUrl">Figma íŒŒì¼ URL <span style="font-weight:400;color:#999;">(ë¸Œë¼ìš°ì € ì£¼ì†Œì°½ì—ì„œ
              ë³µì‚¬)</span></label>
          <div class="input-wrapper">
            <input type="text" id="figmaFileUrl" placeholder="https://www.figma.com/design/ABC123.../...">
          </div>
        </div>
        <div class="input-group">
          <label for="figmaToken">Figma Personal Access Token</label>
          <div class="input-wrapper">
            <input type="password" id="figmaToken" placeholder="figd_xxx...">
            <button type="button" class="toggle-visibility" data-target="figmaToken" title="ë¹„ë°€ë²ˆí˜¸ ë³´ê¸°">ğŸ‘</button>
          </div>
        </div>
        <div class="input-group">
          <label for="geminiKey">Gemini API Key</label>
          <div class="input-wrapper">
            <input type="password" id="geminiKey" placeholder="AIza... (Google AI Studioì—ì„œ ë¬´ë£Œ ë°œê¸‰ ê°€ëŠ¥)">
            <button type="button" class="toggle-visibility" data-target="geminiKey" title="ë¹„ë°€ë²ˆí˜¸ ë³´ê¸°">ğŸ‘</button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancelSettings">ì·¨ì†Œ</button>
        <button class="btn btn-primary" id="saveSettings">ì €ì¥</button>
      </div>
    </div>
  </div>

  <script>
    // DOM Elements
    const dateRangeSelect = document.getElementById('dateRange');
    const tabAll = document.getElementById('tabAll');
    const tabPending = document.getElementById('tabPending');
    const emptyState = document.getElementById('emptyState');
    const commentList = document.getElementById('commentList');
    const openSettingsBtn = document.getElementById('openSettings');
    const settingsModal = document.getElementById('settingsModal');
    const cancelSettingsBtn = document.getElementById('cancelSettings');
    const saveSettingsBtn = document.getElementById('saveSettings');
    const figmaTokenInput = document.getElementById('figmaToken');
    const geminiKeyInput = document.getElementById('geminiKey');
    const figmaFileUrlInput = document.getElementById('figmaFileUrl');
    const toast = document.getElementById('toast');
    const settingsStatus = document.getElementById('settingsStatus');
    const toggleButtons = document.querySelectorAll('.toggle-visibility');

    // Toast ì•Œë¦¼ í‘œì‹œ í•¨ìˆ˜
    function showToast(message, type = 'default') {
      toast.textContent = message;
      toast.className = 'toast show ' + type;
      setTimeout(() => {
        toast.className = 'toast';
      }, 3000);
    }

    // ì„¤ì • ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateSettingsStatus(hasSettings) {
      if (hasSettings) {
        settingsStatus.textContent = 'ì„¤ì •ë¨ âœ“';
        settingsStatus.className = 'settings-status configured';
      } else {
        settingsStatus.textContent = 'ë¯¸ì„¤ì •';
        settingsStatus.className = 'settings-status not-configured';
      }
    }

    // Figma URLì—ì„œ fileKey ì¶”ì¶œ
    // ì§€ì› í˜•ì‹: /file/{key}/..., /design/{key}/..., /board/{key}/...
    function extractFileKeyFromUrl(url) {
      const match = url.match(/figma\.com\/(file|design|board)\/([a-zA-Z0-9]+)/);
      return match ? match[2] : null;
    }

    // Tab switching
    let currentFilter = 'all'; // 'all' | 'pending'
    let allClassifiedComments = []; // ë¶„ë¥˜ëœ ì½”ë©˜íŠ¸ ì „ì²´ ì €ì¥
    let currentCheckedStates = {}; // ì²´í¬ ìƒíƒœ

    tabAll.addEventListener('click', () => {
      tabAll.classList.add('active');
      tabPending.classList.remove('active');
      currentFilter = 'all';
      applyFilter();
    });

    tabPending.addEventListener('click', () => {
      tabPending.classList.add('active');
      tabAll.classList.remove('active');
      currentFilter = 'pending';
      applyFilter();
    });

    // Date range change
    dateRangeSelect.addEventListener('change', (e) => {
      const range = e.target.value;
      parent.postMessage({ pluginMessage: { type: 'date-range-changed', range } }, '*');
    });

    // Password visibility toggle
    toggleButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const targetId = btn.getAttribute('data-target');
        const input = document.getElementById(targetId);
        if (input.type === 'password') {
          input.type = 'text';
          btn.textContent = 'ğŸ™ˆ';
          btn.title = 'ë¹„ë°€ë²ˆí˜¸ ìˆ¨ê¸°ê¸°';
        } else {
          input.type = 'password';
          btn.textContent = 'ğŸ‘';
          btn.title = 'ë¹„ë°€ë²ˆí˜¸ ë³´ê¸°';
        }
      });
    });

    // Settings modal
    openSettingsBtn.addEventListener('click', () => {
      settingsModal.classList.add('show');
    });

    cancelSettingsBtn.addEventListener('click', () => {
      settingsModal.classList.remove('show');
    });

    saveSettingsBtn.addEventListener('click', () => {
      const figmaToken = figmaTokenInput.value.trim();
      const geminiKey = geminiKeyInput.value.trim();
      const fileUrl = figmaFileUrlInput.value.trim();

      // Figma URLì—ì„œ fileKey ì¶”ì¶œ
      if (fileUrl) {
        const extractedKey = extractFileKeyFromUrl(fileUrl);
        if (extractedKey) {
          parent.postMessage({
            pluginMessage: { type: 'save-file-key', fileKey: extractedKey }
          }, '*');
          window.fileKey = extractedKey;
        } else {
          showToast('Figma URL í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.', 'error');
          return;
        }
      }

      parent.postMessage({
        pluginMessage: {
          type: 'save-api-keys',
          figmaToken,
          geminiKey
        }
      }, '*');
      settingsModal.classList.remove('show');
    });

    // Close modal when clicking overlay
    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) {
        settingsModal.classList.remove('show');
      }
    });

    // Receive messages from plugin code
    window.onmessage = (event) => {
      const message = event.data.pluginMessage;
      if (!message) return;

      switch (message.type) {
        case 'load-settings':
          // Pre-fill saved API keys
          if (message.figmaToken) figmaTokenInput.value = message.figmaToken;
          if (message.geminiKey) geminiKeyInput.value = message.geminiKey;
          // ì„¤ì • ìƒíƒœ ì—…ë°ì´íŠ¸
          updateSettingsStatus(message.hasSettings);
          break;

        case 'settings-saved':
          // ì €ì¥ ê²°ê³¼ Toast í‘œì‹œ
          showToast(message.message, message.success ? 'success' : 'error');
          if (message.success) {
            updateSettingsStatus(true);
          }
          break;

        case 'file-info':
          // íŒŒì¼ ì •ë³´ ì €ì¥
          window.fileKey = message.fileKey;
          window.fileName = message.fileName;
          console.log('ğŸ“ íŒŒì¼ ì •ë³´:', message.fileName, message.fileKey);
          // fileKeyê°€ ì—†ìœ¼ë©´ ì„¤ì • ëª¨ë‹¬ ìë™ ì˜¤í”ˆ
          if (!message.fileKey) {
            console.log('âš ï¸ fileKeyê°€ ì—†ìŠµë‹ˆë‹¤. ì„¤ì •ì—ì„œ Figma íŒŒì¼ URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
          }
          break;

        case 'file-key-saved':
          window.fileKey = message.fileKey;
          showToast('íŒŒì¼ í‚¤ ì €ì¥ ì™„ë£Œ!', 'success');
          break;

        case 'fetch-comments-request':
          // code.tsì—ì„œ ìš”ì²­ì´ ì˜¤ë©´ ì‹¤ì œ API í˜¸ì¶œ ìˆ˜í–‰
          fetchComments(message.fileKey, message.figmaToken, message.range, message.lastCheckTime);
          break;

        case 'zoom-failed':
          showToast(message.message, 'error');
          break;

        case 'fetch-error':
          // ì—ëŸ¬ í‘œì‹œ
          showToast(message.error, 'error');
          updateEmptyState('error', message.error);
          break;

        case 'comments-loaded':
          console.log(`ğŸ“‹ UIì—ì„œ ${message.count}ê°œ ì½”ë©˜íŠ¸ ìˆ˜ì‹ `);
          currentCheckedStates = message.checkedStates || {};
          if (message.count === 0) {
            updateEmptyState('empty', 'í•´ë‹¹ ê¸°ê°„ì— ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
          } else {
            classifyAndRenderComments(message.comments);
          }
          break;
      }
    };

    // ===== Phase 1-2: Figma REST API ì½”ë©˜íŠ¸ ì¡°íšŒ =====

    // ê¸°ê°„ í•„í„° ê³„ì‚° í•¨ìˆ˜
    function getDateFilter(range, lastCheckTime) {
      const now = new Date();
      let sinceDate;

      switch (range) {
        case '24h':
          sinceDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
          break;
        case '3d':
          sinceDate = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000);
          break;
        case '1w':
          sinceDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          break;
        case 'last':
          sinceDate = lastCheckTime ? new Date(lastCheckTime) : new Date(now.getTime() - 24 * 60 * 60 * 1000);
          break;
        default:
          sinceDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
      }

      return sinceDate.toISOString();
    }

    // ì½”ë©˜íŠ¸ ì¡°íšŒ í•¨ìˆ˜
    async function fetchComments(fileKey, figmaToken, range, lastCheckTime) {
      // ë¡œë”© ìƒíƒœ í‘œì‹œ
      updateEmptyState('loading', 'ì½”ë©˜íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');

      try {
        const response = await fetch(
          `https://api.figma.com/v1/files/${fileKey}/comments`,
          {
            method: 'GET',
            headers: {
              'X-Figma-Token': figmaToken
            }
          }
        );

        if (!response.ok) {
          let errorMessage = 'ì½”ë©˜íŠ¸ë¥¼ ê°€ì ¸ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
          if (response.status === 403) {
            errorMessage = 'API í† í°ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì„¤ì •í•´ì£¼ì„¸ìš”.';
          } else if (response.status === 404) {
            errorMessage = 'íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
          }
          throw new Error(errorMessage);
        }

        const data = await response.json();
        const allComments = data.comments || [];

        // ê¸°ê°„ í•„í„°ë§
        const sinceDate = getDateFilter(range, lastCheckTime);
        const filteredComments = allComments.filter(comment => {
          return new Date(comment.created_at) >= new Date(sinceDate);
        });

        console.log(`ğŸ” ì „ì²´ ${allComments.length}ê°œ ì¤‘ ${filteredComments.length}ê°œ í•„í„°ë¨ (${range})`);

        // code.tsì— ê²°ê³¼ ì „ë‹¬ (allCommentsëŠ” ë¶€ëª¨ ì½”ë©˜íŠ¸ ë§¤í•‘ìš©)
        parent.postMessage({
          pluginMessage: {
            type: 'comments-fetched',
            comments: filteredComments,
            allCommentsForLookup: allComments
          }
        }, '*');

        // ë¡œë”© ì™„ë£Œ Toast
        showToast(`${filteredComments.length}ê°œ ì½”ë©˜íŠ¸ ë¡œë“œ ì™„ë£Œ`, 'success');

      } catch (error) {
        console.error('âŒ ì½”ë©˜íŠ¸ ì¡°íšŒ ì‹¤íŒ¨:', error);
        parent.postMessage({
          pluginMessage: {
            type: 'comments-fetch-error',
            error: error.message
          }
        }, '*');
      }
    }

    // Empty State ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateEmptyState(state, message) {
      const emptyIcon = emptyState.querySelector('.empty-icon');
      const emptyTitle = emptyState.querySelector('.empty-title');
      const emptyDesc = emptyState.querySelector('.empty-desc');

      switch (state) {
        case 'loading':
          emptyIcon.innerHTML = `
            <svg class="spinner" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 12a9 9 0 11-6.219-8.56"></path>
            </svg>
          `;
          emptyTitle.textContent = message || 'ë¡œë”© ì¤‘...';
          emptyDesc.textContent = '';
          break;
        case 'error':
          emptyIcon.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#e53935" stroke-width="2">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="15" y1="9" x2="9" y2="15"></line>
              <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
          `;
          emptyTitle.textContent = 'ì˜¤ë¥˜ ë°œìƒ';
          emptyDesc.textContent = message || '';
          break;
        case 'empty':
          emptyIcon.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
          `;
          emptyTitle.textContent = message || 'ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤';
          emptyDesc.textContent = 'ê¸°ê°„ì„ ë³€ê²½í•´ë³´ì„¸ìš”';
          break;
        default:
          emptyIcon.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
          `;
          emptyTitle.textContent = 'ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤';
          emptyDesc.textContent = 'ê¸°ê°„ì„ ì„ íƒí•˜ê³  API í‚¤ë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”';
      }
    }

    // ===== Gemini API í†µì‹  í•¨ìˆ˜ (429 ìë™ ì¬ì‹œë„ í¬í•¨) =====

    async function callGeminiAPI(geminiKey, promptText, maxRetries = 3) {
      const GEMINI_MODEL = 'gemini-2.0-flash';
      const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${geminiKey}`;

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{ parts: [{ text: promptText }] }],
            generationConfig: {
              temperature: 0.2,
              maxOutputTokens: 4096,
              responseMimeType: 'application/json'
            }
          })
        });

        if (response.ok) {
          const data = await response.json();
          const resultText = data.candidates?.[0]?.content?.parts?.[0]?.text;
          if (!resultText) throw new Error('Gemini ì‘ë‹µì—ì„œ ê²°ê³¼ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          return JSON.parse(resultText);
        }

        if (response.status === 429 && attempt < maxRetries) {
          const backoffSec = 5 * Math.pow(2, attempt); // 5ì´ˆ, 10ì´ˆ, 20ì´ˆ
          console.warn(`â³ 429 Rate Limit â†’ ${backoffSec}ì´ˆ í›„ ì¬ì‹œë„ (${attempt + 1}/${maxRetries})`);
          await sleep(backoffSec * 1000);
          continue;
        }

        let errorMessage = 'Gemini API í˜¸ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
        if (response.status === 400) errorMessage = 'Gemini API í‚¤ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.';
        else if (response.status === 429) errorMessage = `API í˜¸ì¶œ í•œë„ ì´ˆê³¼. ${maxRetries}íšŒ ì¬ì‹œë„ ì‹¤íŒ¨.`;
        throw new Error(errorMessage);
      }
    }

    // ===== One-Shot í”„ë ˆì„ë³„ í†µí•© ì²˜ë¦¬ (ë¶„ë¥˜ + ìš”ì•½) =====

    const FRAME_DELAY_MS = 1000; // í”„ë ˆì„ ê°„ 1ì´ˆ ë”œë ˆì´

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // ì½”ë©˜íŠ¸ë¥¼ leaf-frame ë‹¨ìœ„ë¡œ ê·¸ë£¹í•‘ (hierarchy ëë‹¨ ê¸°ì¤€)
    function groupByLeafFrame(comments) {
      const frameGroups = {};
      comments.forEach(c => {
        const h = c.hierarchy || [];
        // leaf-frame key: hierarchy ì „ì²´ ê²½ë¡œ (ì˜ˆ: "8-3. Digital Key > P-8300-1")
        const key = h.length > 1
          ? h.slice(1).map(a => a.name).join(' > ')
          : h.length === 1 ? h[0].name : 'ê¸°íƒ€';
        if (!frameGroups[key]) frameGroups[key] = [];
        frameGroups[key].push(c);
      });
      return frameGroups;
    }

    // ì½”ë©˜íŠ¸ë¥¼ ì“°ë ˆë“œ ë‹¨ìœ„ë¡œ ë¬¶ê¸°
    function groupByThread(comments) {
      const threads = {};
      // ë¶€ëª¨ ì½”ë©˜íŠ¸ ë¨¼ì €
      comments.filter(c => !c.isReply).forEach(c => {
        threads[c.id] = { parent: c, replies: [] };
      });
      // ë‹µê¸€ ì¶”ê°€
      comments.filter(c => c.isReply).forEach(c => {
        if (threads[c.threadId]) {
          threads[c.threadId].replies.push(c);
        } else {
          // ë¶€ëª¨ê°€ í•„í„° ë°–ì´ë©´ ë‹µê¸€ì„ ë…ë¦½ ì“°ë ˆë“œë¡œ
          threads[c.threadId] = { parent: c, replies: [] };
        }
      });
      // ì‹œê°„ìˆœ ì •ë ¬
      Object.values(threads).forEach(t => {
        t.replies.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
      });
      return threads;
    }

    // ìš”ì•½ ë°ì´í„° ì €ì¥ì†Œ: framePath â†’ { summary, classifiedComments }
    let allFrameSummaries = {};

    async function classifyAndRenderComments(comments) {
      const geminiKey = geminiKeyInput.value.trim();

      // API í‚¤ ì—†ìœ¼ë©´ ë¶„ë¥˜ ì—†ì´ ë°”ë¡œ ë Œë”ë§
      if (!geminiKey) {
        allClassifiedComments = comments.map(comment => ({
          ...comment,
          category: 'discussion',
          priority: 'normal',
          summary: comment.message.substring(0, 30),
          checked: currentCheckedStates[comment.id] || false
        }));
        renderCommentList(allClassifiedComments);
        showToast('Gemini API í‚¤ê°€ ì—†ì–´ ë¶„ë¥˜ ì—†ì´ í‘œì‹œí•©ë‹ˆë‹¤.', 'error');
        return;
      }

      // ë¡œë”© í™”ë©´ í‘œì‹œ (AI ë¶„ì„ ì™„ë£Œê¹Œì§€ ì½˜í…ì¸  ìˆ¨ê¹€)
      commentList.style.display = 'none';
      emptyState.style.display = 'flex';

      allClassifiedComments = comments.map(comment => ({
        ...comment,
        category: 'discussion',
        priority: 'normal',
        summary: comment.message.substring(0, 30),
        checked: currentCheckedStates[comment.id] || false
      }));
      allFrameSummaries = {};

      // leaf-frame ë‹¨ìœ„ë¡œ ê·¸ë£¹í•‘
      const frameGroups = groupByLeafFrame(allClassifiedComments);
      const framePaths = Object.keys(frameGroups);
      console.log(`ğŸš€ ${framePaths.length}ê°œ í”„ë ˆì„(leaf) í†µí•© ì²˜ë¦¬ ì‹œì‘`);

      updateEmptyState('loading', `AI ë¶„ì„ ì¤‘... (0/${framePaths.length} í”„ë ˆì„)`);

      let failedFrames = 0;

      for (let i = 0; i < framePaths.length; i++) {
        const framePath = framePaths[i];
        const frameComments = frameGroups[framePath];

        updateEmptyState('loading', `AI ë¶„ì„ ì¤‘... (${i + 1}/${framePaths.length}: ${framePath})`);

        // ì½”ë©˜íŠ¸ 1ê°œ ì´í•˜ë©´ ê°„ë‹¨ ì²˜ë¦¬
        if (frameComments.length < 2) {
          const c = frameComments[0];
          allFrameSummaries[framePath] = {
            summary: {
              title: c.message.substring(0, 15),
              status: 'Open',
              issues: [],
              decisions: []
            },
            classifiedComments: [{
              id: c.id, category: 'discussion', priority: 'normal',
              summary: c.message.substring(0, 20)
            }]
          };
          applyFrameResult(framePath, allFrameSummaries[framePath], frameComments);
          continue;
        }

        try {
          // ì“°ë ˆë“œ êµ¬ì¡°ë¡œ í”„ë¡¬í”„íŠ¸ ìƒì„±
          const threads = groupByThread(frameComments);
          const prompt = buildThreadAwarePrompt(framePath, threads);
          const result = await callGeminiAPI(geminiKey, prompt);
          allFrameSummaries[framePath] = result;
          applyFrameResult(framePath, result, frameComments);
          console.log(`  âœ… "${framePath}" ì™„ë£Œ (${frameComments.length}ê°œ ì½”ë©˜íŠ¸, ${Object.keys(threads).length} ì“°ë ˆë“œ)`);
        } catch (error) {
          console.warn(`  âš ï¸ "${framePath}" ì‹¤íŒ¨:`, error.message);
          failedFrames++;
          allFrameSummaries[framePath] = {
            summary: { title: 'ë¶„ì„ ì‹¤íŒ¨', status: 'Error', issues: [], decisions: [] },
            classifiedComments: []
          };
        }

        if (i < framePaths.length - 1) {
          await sleep(FRAME_DELAY_MS);
        }
      }

      // ìµœì¢… ë Œë”ë§
      renderCommentList(allClassifiedComments);

      const successFrames = framePaths.length - failedFrames;
      if (failedFrames === 0) {
        showToast(`${framePaths.length}ê°œ í”„ë ˆì„ ë¶„ì„ ì™„ë£Œ`, 'success');
      } else {
        showToast(`${successFrames}/${framePaths.length} í”„ë ˆì„ ì„±ê³µ, ${failedFrames}ê°œ ì‹¤íŒ¨`, 'error');
      }
    }

    // í”„ë ˆì„ ê²°ê³¼ë¥¼ allClassifiedCommentsì— ë°˜ì˜
    function applyFrameResult(framePath, result, frameComments) {
      const classified = result.classifiedComments || [];
      frameComments.forEach(comment => {
        const match = classified.find(c => c.id === comment.id);
        if (match) {
          const idx = allClassifiedComments.findIndex(c => c.id === comment.id);
          if (idx !== -1) {
            allClassifiedComments[idx].category = match.category || 'discussion';
            allClassifiedComments[idx].priority = match.priority || 'normal';
            allClassifiedComments[idx].summary = match.summary || comment.message.substring(0, 20);
          }
        }
      });
    }

    function buildThreadAwarePrompt(framePath, threads) {
      // ì“°ë ˆë“œ êµ¬ì¡°ë¡œ ì½”ë©˜íŠ¸ ì •ë¦¬
      const threadList = Object.values(threads).map(t => {
        const parentMsg = `[ë¶€ëª¨] "${t.parent.user?.handle || 'unknown'}": "${t.parent.message.replace(/"/g, '\\"').replace(/\n/g, ' ').substring(0, 300)}"`;
        const replies = t.replies.map(r =>
          `  [ë‹µê¸€] "${r.user?.handle || 'unknown'}": "${r.message.replace(/"/g, '\\"').replace(/\n/g, ' ').substring(0, 200)}"`
        ).join('\n');
        const ids = [t.parent.id, ...t.replies.map(r => r.id)].join(',');
        return `ì“°ë ˆë“œ(ids:${ids}):\n${parentMsg}${replies ? '\n' + replies : ''}`;
      }).join('\n\n');

      return `ì•„ë˜ëŠ” Figma í”„ë ˆì„ "${framePath}"ì— ë‹¬ë¦° ì½”ë©˜íŠ¸ ëŒ€í™”ì…ë‹ˆë‹¤.
ì“°ë ˆë“œ(ë¶€ëª¨+ë‹µê¸€) ë‹¨ìœ„ë¡œ ì •ë¦¬ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

[ì“°ë ˆë“œ ëª©ë¡]
${threadList}

=== ë¶„ì„ ìš”ì²­ ===
1) summary: ì´ í”„ë ˆì„ì˜ ì „ì²´ ëŒ€í™”ë¥¼ í•œêµ­ì–´ë¡œ ìš”ì•½
2) classifiedComments: ê° ì½”ë©˜íŠ¸ë¥¼ ë¶„ë¥˜ (ë¶€ëª¨+ë‹µê¸€ ëª¨ë‘)

JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µ:
{
  "summary": {
    "title": "í•µì‹¬ ì£¼ì œ 15ìì´ë‚´",
    "status": "Open ë˜ëŠ” Resolved",
    "issues": ["ì£¼ìš” ì´ìŠˆ (í•œêµ­ì–´)"],
    "decisions": ["ê²°ì •/ì™„ë£Œëœ ê²ƒ (í•œêµ­ì–´)"]
  },
  "classifiedComments": [
    {"id":"ì›ë³¸id","category":"bug|change_request|question|discussion","priority":"urgent|normal","summary":"í•œêµ­ì–´ í•œì¤„ìš”ì•½ 20ìì´ë‚´"}
  ]
}`;
    }

    // ===== Phase 1-4: UI ë Œë”ë§ =====

    const CATEGORY_MAP = {
      bug: { label: 'ë²„ê·¸', cssClass: 'tag-bug', icon: 'ğŸ”´' },
      change_request: { label: 'ìˆ˜ì • ìš”ì²­', cssClass: 'tag-change', icon: 'ğŸŸ ' },
      question: { label: 'ì§ˆë¬¸', cssClass: 'tag-question', icon: 'ğŸ”µ' },
      discussion: { label: 'ë…¼ì˜', cssClass: 'tag-feedback', icon: 'âšª' }
    };

    function renderCommentList(comments) {
      // í•„í„° ì ìš©
      let filtered = comments;
      if (currentFilter === 'pending') {
        filtered = comments.filter(c => !c.resolved_at);
      }

      // Level 1: ìµœìƒìœ„ Sectionë³„ ê·¸ë£¹í•‘
      const sectionGroups = {};
      filtered.forEach(comment => {
        const key = comment.frameName || 'ê¸°íƒ€';
        if (!sectionGroups[key]) sectionGroups[key] = [];
        sectionGroups[key].push(comment);
      });

      const sortedSections = Object.keys(sectionGroups).sort((a, b) => sectionGroups[b].length - sectionGroups[a].length);

      if (sortedSections.length === 0) {
        emptyState.style.display = 'flex';
        commentList.style.display = 'none';
        updateEmptyState('empty', currentFilter === 'pending' ? 'ë¯¸ì™„ë£Œ ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤' : 'í•´ë‹¹ ê¸°ê°„ì— ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
        updateTabCounts(comments);
        return;
      }

      let html = '';
      let globalIdx = 0;

      sortedSections.forEach(sectionName => {
        const sectionComments = sectionGroups[sectionName];

        // Section í—¤ë” (category badges)
        const categoryCounts = {};
        sectionComments.forEach(c => {
          categoryCounts[c.category] = (categoryCounts[c.category] || 0) + 1;
        });
        const categoryBadges = Object.entries(categoryCounts)
          .map(([cat, count]) => `${CATEGORY_MAP[cat]?.icon || 'âšª'} ${count}`)
          .join(' ');

        html += `<div class="comment-group">`;
        html += `<div class="group-header">
          <span class="group-icon">ğŸ“</span>
          <span>${sectionName}</span>
          <span style="margin-left:auto; font-size:10px; color:#999; font-weight:400;">${categoryBadges}</span>
        </div>`;

        // Level 1 ì•„ì½”ë””ì–¸ í† ê¸€
        html += `<button class="group-toggle" data-frame="${sectionName}">
          <span class="toggle-arrow">â–¶</span> ì½”ë©˜íŠ¸ ${sectionComments.length}ê±´ ë³´ê¸°
        </button>`;

        html += `<div class="comment-items-container collapsed" data-frame-items="${sectionName}">`;

        // Level 2: Sub-Sectionë³„ ê·¸ë£¹í•‘ (hierarchy[1])
        const subSectionGroups = {};
        sectionComments.forEach(c => {
          const h = c.hierarchy || [];
          const subKey = h.length > 1 ? h[1].name : 'ì¼ë°˜';
          if (!subSectionGroups[subKey]) subSectionGroups[subKey] = [];
          subSectionGroups[subKey].push(c);
        });

        const subSectionKeys = Object.keys(subSectionGroups).sort((a, b) => {
          if (a === 'ì¼ë°˜') return 1;
          if (b === 'ì¼ë°˜') return -1;
          return subSectionGroups[b].length - subSectionGroups[a].length;
        });

        const hasMultipleSubs = subSectionKeys.length > 1 || (subSectionKeys.length === 1 && subSectionKeys[0] !== 'ì¼ë°˜');

        subSectionKeys.forEach(subName => {
          const subComments = subSectionGroups[subName];
          const subId = `sub_${globalIdx++}`;

          // Level 2 í—¤ë” (Sub-Section)
          if (hasMultipleSubs && subName !== 'ì¼ë°˜') {
            html += `<div class="frame-header" data-frame-id="${subId}">
              <span class="frame-arrow open">â–¶</span>
              <span>ğŸ“‚</span>
              <span>${subName}</span>
              <span class="frame-count">${subComments.length}ê±´</span>
            </div>`;
          } else if (hasMultipleSubs && subName === 'ì¼ë°˜') {
            html += `<div class="frame-header" data-frame-id="${subId}">
              <span class="frame-arrow open">â–¶</span>
              <span>ğŸ“</span>
              <span>ê¸°íƒ€ ì½”ë©˜íŠ¸</span>
              <span class="frame-count">${subComments.length}ê±´</span>
            </div>`;
          }

          if (hasMultipleSubs) {
            html += `<div class="frame-items-container" data-frame-items-id="${subId}">`;
          }

          // Level 3: Frameë³„ ê·¸ë£¹í•‘ (hierarchy[2:])
          const frameGroups = {};
          subComments.forEach(c => {
            const h = c.hierarchy || [];
            const frameKey = h.length > 2
              ? h.slice(2).map(a => a.name).join(' > ')
              : 'ì¼ë°˜';
            if (!frameGroups[frameKey]) frameGroups[frameKey] = [];
            frameGroups[frameKey].push(c);
          });

          const frameKeys = Object.keys(frameGroups).sort((a, b) => {
            if (a === 'ì¼ë°˜') return 1;
            if (b === 'ì¼ë°˜') return -1;
            return frameGroups[b].length - frameGroups[a].length;
          });

          const hasMultipleFrames = frameKeys.length > 1 || (frameKeys.length === 1 && frameKeys[0] !== 'ì¼ë°˜');

          frameKeys.forEach(frameName => {
            const frameComments = frameGroups[frameName];
            const frameId = `frame_${globalIdx++}`;

            // Level 3 í—¤ë” (Frame)
            if (hasMultipleFrames && frameName !== 'ì¼ë°˜') {
              html += `<div class="frame-header" data-frame-id="${frameId}" style="padding-left:20px;">
                <span class="frame-arrow open">â–¶</span>
                <span>ğŸ–¼</span>
                <span>${frameName}</span>
                <span class="frame-count">${frameComments.length}ê±´</span>
              </div>`;
            }

            if (hasMultipleFrames) {
              html += `<div class="frame-items-container" data-frame-items-id="${frameId}">`;
            }

            // Frame-level AI ìš”ì•½ ì¹´ë“œ
            const summaryKey = subName !== 'ì¼ë°˜' && frameName !== 'ì¼ë°˜'
              ? `${subName} > ${frameName}`
              : subName !== 'ì¼ë°˜' ? subName : frameName;
            const frameData = allFrameSummaries[summaryKey];
            const summary = frameData?.summary;
            if (summary && summary.title !== 'ë¶„ì„ ì‹¤íŒ¨') {
              const statusColor = summary.status === 'Resolved' ? '#4caf50' : '#fb8c00';
              const statusLabel = summary.status === 'Resolved' ? 'âœ… í•´ê²°ë¨' : 'ğŸ”„ ì§„í–‰ ì¤‘';
              html += `<div class="summary-card">`;
              html += `<div class="summary-card-title">ğŸ’¡ ${summary.title} <span style="font-size:10px;color:${statusColor};margin-left:6px;">${statusLabel}</span></div>`;
              if (summary.issues?.length) html += summary.issues.map(i => `<div class="summary-card-section"><span class="section-icon">ğŸ“Œ</span>${i}</div>`).join('');
              if (summary.decisions?.length) html += summary.decisions.map(d => `<div class="summary-card-section"><span class="section-icon">âœ…</span>${d}</div>`).join('');
              html += `</div>`;
            } else if (!frameData) {
              html += `<div class="summary-card"><span class="summary-card-loading">ğŸ’¡ ìš”ì•½ ìƒì„± ì¤‘...</span></div>`;
            }

            // ì“°ë ˆë“œ ë‹¨ìœ„ ë Œë”ë§
            const threads = groupByThread(frameComments);
            const threadEntries = Object.values(threads).sort((a, b) => {
              if (a.parent.priority === 'urgent' && b.parent.priority !== 'urgent') return -1;
              if (b.parent.priority === 'urgent' && a.parent.priority !== 'urgent') return 1;
              return new Date(b.parent.created_at) - new Date(a.parent.created_at);
            });

            threadEntries.forEach(thread => {
              const p = thread.parent;
              const cat = CATEGORY_MAP[p.category] || CATEGORY_MAP.discussion;
              const nodeId = p.resolvedNodeId || p.client_meta?.node_id || '';
              const urgentBadge = p.priority === 'urgent'
                ? '<span style="background:#ffebee;color:#e53935;padding:1px 5px;border-radius:3px;font-size:9px;font-weight:600;margin-left:4px;">ê¸´ê¸‰</span>'
                : '';
              const replyCount = thread.replies.length;
              const threadId = `thread_${p.threadId || p.id}`;

              html += `<div class="thread-card" data-thread-id="${threadId}">`;

              // ì“°ë ˆë“œ í—¤ë“œ (ë¶€ëª¨ ì½”ë©˜íŠ¸)
              html += `<div class="thread-head" data-node-id="${nodeId}">
                <div class="comment-content">
                  <span class="comment-tag ${cat.cssClass}">${cat.label}</span>${urgentBadge}
                  <p class="comment-summary">${p.summary || p.message.substring(0, 40)}</p>
                  <p class="comment-meta">@${p.user?.handle || 'unknown'} Â· ${formatRelativeTime(p.created_at)}</p>
                  ${replyCount > 0 ? `<p class="thread-reply-badge">ğŸ’¬ ${replyCount}ê°œ ë‹µê¸€ Â· í´ë¦­í•˜ì—¬ í¼ì¹˜ê¸°</p>` : ''}
                </div>
              </div>`;

              // ë‹µê¸€ ë¦¬ìŠ¤íŠ¸ (ê¸°ë³¸ ì ‘íŒ ìƒíƒœ)
              if (replyCount > 0) {
                html += `<div class="thread-replies" data-thread-replies="${threadId}">`;
                thread.replies.forEach(r => {
                  html += `<div class="thread-reply-item" data-node-id="${r.resolvedNodeId || ''}" data-comment-id="${r.id}">
                    <div>
                      <div class="reply-msg">${r.summary || r.message.substring(0, 60)}</div>
                      <div class="reply-meta">@${r.user?.handle || 'unknown'} Â· ${formatRelativeTime(r.created_at)}</div>
                    </div>
                  </div>`;
                });
                html += `</div>`;
              }

              html += `</div>`; // thread-card
            });

            if (hasMultipleFrames) {
              html += `</div>`; // frame-items-container (Level 3)
            }
          });

          if (hasMultipleSubs) {
            html += `</div>`; // frame-items-container (Level 2)
          }
        });

        html += `</div>`; // comment-items-container (Level 1)
        html += `</div>`; // comment-group
      });

      commentList.innerHTML = html;
      emptyState.style.display = 'none';
      commentList.style.display = 'block';

      updateTabCounts(comments);
      attachCommentEvents();
    }

    function attachCommentEvents() {
      // Level 1: Section ì•„ì½”ë””ì–¸ í† ê¸€
      commentList.querySelectorAll('.group-toggle').forEach(btn => {
        btn.addEventListener('click', () => {
          const frameName = btn.getAttribute('data-frame');
          const container = commentList.querySelector(`[data-frame-items="${frameName}"]`);
          const arrow = btn.querySelector('.toggle-arrow');
          if (!container) return;

          if (container.classList.contains('collapsed')) {
            container.classList.remove('collapsed');
            container.style.maxHeight = container.scrollHeight + 'px';
            arrow.classList.add('open');
            btn.innerHTML = `<span class="toggle-arrow open">â–¶</span> ì½”ë©˜íŠ¸ ì ‘ê¸°`;
          } else {
            container.classList.add('collapsed');
            container.style.maxHeight = '0';
            arrow.classList.remove('open');
            const count = container.querySelectorAll('.thread-card').length;
            btn.innerHTML = `<span class="toggle-arrow">â–¶</span> ì½”ë©˜íŠ¸ ${count}ê±´ ë³´ê¸°`;
          }
        });
      });

      // Level 2/3: Sub-Section, Frame ê·¸ë£¹ í† ê¸€
      commentList.querySelectorAll('.frame-header').forEach(header => {
        header.addEventListener('click', () => {
          const frameId = header.getAttribute('data-frame-id');
          const container = commentList.querySelector(`[data-frame-items-id="${frameId}"]`);
          const arrow = header.querySelector('.frame-arrow');
          if (!container) return;

          if (container.classList.contains('frame-collapsed')) {
            container.classList.remove('frame-collapsed');
            container.style.maxHeight = container.scrollHeight + 'px';
            if (arrow) arrow.classList.add('open');
          } else {
            container.classList.add('frame-collapsed');
            container.style.maxHeight = '0';
            if (arrow) arrow.classList.remove('open');
          }

          // ëª¨ë“  ë¶€ëª¨ ì»¨í…Œì´ë„ˆì˜ maxHeight ì¬ê³„ì‚°
          let parent = header.closest('.frame-items-container') || header.closest('.comment-items-container');
          setTimeout(() => {
            while (parent) {
              if (!parent.classList.contains('collapsed') && !parent.classList.contains('frame-collapsed')) {
                parent.style.maxHeight = parent.scrollHeight + 'px';
              }
              parent = parent.parentElement?.closest('.frame-items-container') || parent.parentElement?.closest('.comment-items-container');
              if (parent && parent === header.closest('.comment-items-container')?.parentElement) break;
            }
          }, 350);
        });
      });

      // ì“°ë ˆë“œ í´ë¦­ â†’ ë‹µê¸€ í¼ì¹¨ + ì¤Œì¸
      commentList.querySelectorAll('.thread-head').forEach(head => {
        head.addEventListener('click', (e) => {
          const threadCard = head.closest('.thread-card');
          const repliesContainer = threadCard?.querySelector('.thread-replies');

          // ë‹µê¸€ í† ê¸€
          if (repliesContainer) {
            repliesContainer.classList.toggle('thread-open');
            const badge = head.querySelector('.thread-reply-badge');
            if (badge) {
              badge.textContent = repliesContainer.classList.contains('thread-open')
                ? 'ğŸ’¬ ë‹µê¸€ ì ‘ê¸°'
                : `ğŸ’¬ ${repliesContainer.querySelectorAll('.thread-reply-item').length}ê°œ ë‹µê¸€ Â· í´ë¦­í•˜ì—¬ í¼ì¹˜ê¸°`;
            }
          }

          // ì¤Œì¸
          const nodeId = head.getAttribute('data-node-id');
          if (nodeId) {
            window.parent.postMessage({
              pluginMessage: { type: 'zoom-to-node', nodeId }
            }, '*');
          }

          // ë¶€ëª¨ maxHeight ì¬ê³„ì‚°
          const parentContainer = head.closest('.comment-items-container');
          if (parentContainer && !parentContainer.classList.contains('collapsed')) {
            setTimeout(() => {
              parentContainer.style.maxHeight = parentContainer.scrollHeight + 'px';
            }, 350);
          }
        });
      });
    }

    function formatRelativeTime(dateStr) {
      const diff = Date.now() - new Date(dateStr).getTime();
      const minutes = Math.floor(diff / 60000);
      if (minutes < 1) return 'ë°©ê¸ˆ';
      if (minutes < 60) return `${minutes}ë¶„ ì „`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}ì‹œê°„ ì „`;
      const days = Math.floor(hours / 24);
      if (days < 7) return `${days}ì¼ ì „`;
      return new Date(dateStr).toLocaleDateString('ko-KR');
    }

    function updateTabCounts(comments) {
      const total = comments.length;
      const pending = comments.filter(c => !c.resolved_at).length;
      tabAll.querySelector('.tab-count').textContent = total;
      tabPending.querySelector('.tab-count').textContent = pending;
    }

    function applyFilter() {
      if (allClassifiedComments.length > 0) {
        renderCommentList(allClassifiedComments);
      }
    }
  </script>
</body>

</html>