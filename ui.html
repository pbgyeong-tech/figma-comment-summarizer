<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comment Summarizer</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 12px;
      color: #333;
      background-color: #fff;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* ===== Header ===== */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #e5e5e5;
      background-color: #fafafa;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .logo-icon {
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, #18a0fb 0%, #0d8de5 100%);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      font-weight: 600;
    }

    .logo-text {
      font-size: 13px;
      font-weight: 600;
      color: #1a1a1a;
    }

    .date-picker {
      position: relative;
    }

    .date-select {
      padding: 6px 28px 6px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 11px;
      font-family: 'Inter', sans-serif;
      background-color: #fff;
      color: #333;
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23666' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
    }

    .date-select:focus {
      outline: none;
      border-color: #18a0fb;
    }

    /* ===== Tabs ===== */
    .tabs {
      display: flex;
      border-bottom: 1px solid #e5e5e5;
      background-color: #fff;
    }

    .tab {
      flex: 1;
      padding: 10px 16px;
      font-size: 11px;
      font-weight: 500;
      color: #666;
      background: none;
      border: none;
      cursor: pointer;
      position: relative;
      transition: color 0.2s;
    }

    .tab:hover {
      color: #333;
    }

    .tab.active {
      color: #18a0fb;
    }

    .tab.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      right: 0;
      height: 2px;
      background-color: #18a0fb;
    }

    .tab-count {
      display: inline-block;
      margin-left: 4px;
      padding: 2px 6px;
      background-color: #f0f0f0;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 500;
      color: #666;
    }

    .tab.active .tab-count {
      background-color: #e3f2fd;
      color: #18a0fb;
    }

    /* ===== Content Area ===== */
    .content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #999;
      text-align: center;
    }

    .empty-icon {
      width: 48px;
      height: 48px;
      background-color: #f5f5f5;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 12px;
    }

    .empty-icon svg {
      width: 24px;
      height: 24px;
      stroke: #ccc;
    }

    .empty-title {
      font-size: 13px;
      font-weight: 500;
      color: #666;
      margin-bottom: 4px;
    }

    .empty-desc {
      font-size: 11px;
      color: #999;
    }

    /* ===== Modern Loading Screen ===== */
    .loading-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      gap: 20px;
    }

    .loading-spinner-ring {
      width: 64px;
      height: 64px;
      position: relative;
    }

    .loading-spinner-ring svg {
      width: 64px;
      height: 64px;
      animation: spin 1.5s linear infinite;
    }

    .loading-spinner-ring .ring-bg {
      fill: none;
      stroke: #e8f0fe;
      stroke-width: 4;
    }

    .loading-spinner-ring .ring-fg {
      fill: none;
      stroke: url(#loadingGradient);
      stroke-width: 4;
      stroke-linecap: round;
      stroke-dasharray: 150;
      stroke-dashoffset: 100;
      transition: stroke-dashoffset 0.5s ease;
    }

    .loading-step-text {
      font-size: 14px;
      font-weight: 600;
      color: #333;
      text-align: center;
      transition: opacity 0.3s ease;
      min-height: 22px;
    }

    .loading-sub-text {
      font-size: 11px;
      color: #888;
      text-align: center;
      margin-top: -12px;
      min-height: 16px;
    }

    .loading-progress-wrap {
      width: 200px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }

    .loading-progress-bar {
      width: 100%;
      height: 4px;
      background: #e8f0fe;
      border-radius: 2px;
      overflow: hidden;
    }

    .loading-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4285f4, #18a0fb);
      border-radius: 2px;
      transition: width 0.5s ease;
      width: 0%;
    }

    .loading-progress-label {
      font-size: 10px;
      color: #aaa;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(6px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .fade-in-up {
      animation: fadeInUp 0.3s ease forwards;
    }

    /* ===== Comment List (placeholder) ===== */
    .comment-list {
      display: none;
    }

    .comment-group {
      margin-bottom: 16px;
    }

    .group-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 0;
      font-size: 12px;
      font-weight: 600;
      color: #333;
    }

    .group-icon {
      font-size: 14px;
    }

    .comment-item {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 12px;
      background-color: #fafafa;
      border-radius: 8px;
      margin-bottom: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .comment-item:hover {
      background-color: #f0f0f0;
    }


    .comment-content {
      flex: 1;
    }

    .comment-tag {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
      margin-bottom: 4px;
    }

    .tag-bug {
      background-color: #ffebee;
      color: #e53935;
    }

    .tag-change {
      background-color: #fff3e0;
      color: #fb8c00;
    }

    .tag-question {
      background-color: #e3f2fd;
      color: #1e88e5;
    }

    .tag-feedback {
      background-color: #f5f5f5;
      color: #757575;
    }

    .comment-summary {
      font-size: 12px;
      color: #333;
      line-height: 1.4;
    }

    .comment-meta {
      font-size: 10px;
      color: #999;
      margin-top: 4px;
    }

    /* ===== Footer ===== */
    .footer {
      padding: 12px 16px;
      border-top: 1px solid #e5e5e5;
      background-color: #fafafa;
    }

    .btn-settings {
      width: 100%;
      padding: 10px 16px;
      border: 1px solid #ddd;
      border-radius: 6px;
      background-color: #fff;
      font-size: 11px;
      font-weight: 500;
      font-family: 'Inter', sans-serif;
      color: #666;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .btn-settings:hover {
      border-color: #18a0fb;
      color: #18a0fb;
    }

    .btn-settings svg {
      width: 14px;
      height: 14px;
    }

    /* ===== Modal (API Settings) ===== */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.4);
      z-index: 100;
    }

    .modal-overlay.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal {
      background-color: #fff;
      border-radius: 8px;
      width: 280px;
      max-width: 90%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    }

    .modal-header {
      padding: 16px;
      border-bottom: 1px solid #e5e5e5;
    }

    .modal-title {
      font-size: 14px;
      font-weight: 600;
      color: #1a1a1a;
    }

    .modal-body {
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .input-group label {
      font-size: 11px;
      font-weight: 500;
      color: #666;
    }

    .input-group input {
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 11px;
      font-family: 'Inter', sans-serif;
    }

    .input-group input:focus {
      outline: none;
      border-color: #18a0fb;
    }

    .modal-footer {
      padding: 12px 16px;
      border-top: 1px solid #e5e5e5;
      display: flex;
      gap: 8px;
    }

    .btn {
      flex: 1;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 500;
      font-family: 'Inter', sans-serif;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary {
      background-color: #18a0fb;
      color: white;
      border: none;
    }

    .btn-primary:hover {
      background-color: #0d8de5;
    }

    .btn-secondary {
      background-color: #fff;
      color: #666;
      border: 1px solid #ddd;
    }

    .btn-secondary:hover {
      background-color: #f5f5f5;
    }

    /* ===== Toast Notification ===== */
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background-color: #333;
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
      z-index: 200;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .toast.show {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }

    .toast.success {
      background-color: #4caf50;
    }

    .toast.error {
      background-color: #e53935;
    }

    /* ===== Settings Status Badge ===== */
    .settings-status {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: 6px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
    }

    .settings-status.configured {
      background-color: #e8f5e9;
      color: #4caf50;
    }

    .settings-status.not-configured {
      background-color: #fff3e0;
      color: #fb8c00;
    }

    /* ===== Password Toggle ===== */
    .input-wrapper {
      position: relative;
      display: flex;
      align-items: center;
    }

    .input-wrapper input {
      width: 100%;
      padding-right: 36px;
    }

    .toggle-visibility {
      position: absolute;
      right: 8px;
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      color: #999;
      font-size: 14px;
      line-height: 1;
      transition: color 0.2s;
    }

    .toggle-visibility:hover {
      color: #333;
    }

    /* ===== Spinner Animation ===== */
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    .spinner {
      animation: spin 1s linear infinite;
    }

    /* ===== Smart Summary Card ===== */
    .summary-card {
      background: linear-gradient(135deg, #f0f4ff 0%, #e8f0fe 100%);
      border: 1px solid #d2e3fc;
      border-radius: 8px;
      padding: 10px 12px;
      margin: 6px 4px;
      font-size: 11px;
      line-height: 1.6;
      word-break: break-all;
    }

    .summary-card-title {
      font-weight: 600;
      font-size: 12px;
      margin-bottom: 6px;
      color: #1a73e8;
    }

    .summary-card-section {
      margin: 3px 0;
      color: #333;
    }

    .summary-card-section .section-icon {
      margin-right: 4px;
    }

    .summary-card-loading {
      color: #999;
      font-style: italic;
      padding: 8px 12px;
      font-size: 11px;
    }

    /* ===== Frame-Level Header ===== */
    .frame-header {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 10px;
      margin: 8px 0 2px;
      font-size: 11px;
      font-weight: 600;
      color: #444;
      border-bottom: 1px solid #e0e0e0;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }

    .frame-header:hover {
      background: #f5f5f5;
    }

    .frame-header .frame-arrow {
      font-size: 9px;
      transition: transform 0.2s;
      color: #999;
    }

    .frame-header .frame-arrow.open {
      transform: rotate(90deg);
    }

    .frame-header .frame-count {
      margin-left: auto;
      font-weight: 400;
      font-size: 10px;
      color: #999;
    }

    .frame-items-container {
      overflow: hidden;
      transition: max-height 0.3s ease;
      max-height: none;
    }

    .frame-items-container.frame-collapsed {
      max-height: 0 !important;
    }

    /* ===== Thread Card ===== */
    .thread-card {
      background: #fafafa;
      border-radius: 8px;
      margin: 6px 4px;
      overflow: hidden;
      border: 1px solid #eee;
      transition: border-color 0.2s;
    }

    .thread-card:hover {
      border-color: #ccc;
    }

    .thread-head {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 12px;
      cursor: pointer;
      user-select: none;
    }

    .thread-head .comment-content {
      flex: 1;
    }

    .thread-reply-badge {
      font-size: 10px;
      color: #888;
      margin-top: 4px;
    }

    .thread-replies {
      border-top: 1px solid #eee;
      padding: 0;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .thread-replies.thread-open {
      max-height: none;
    }

    .thread-reply-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 8px 12px 8px 32px;
      background: #f5f5f5;
      border-top: 1px solid #eee;
      font-size: 11px;
    }

    .thread-reply-item .reply-msg {
      color: #555;
      line-height: 1.5;
    }

    .thread-reply-item .reply-meta {
      font-size: 10px;
      color: #999;
      margin-top: 2px;
    }

    .sub-group-header {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 10px;
      margin: 8px 0 2px;
      font-size: 11px;
      font-weight: 600;
      color: #555;
      border-bottom: 1px solid #e0e0e0;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }

    .sub-group-header:hover {
      background: #f5f5f5;
    }

    .sub-group-header .sub-arrow {
      font-size: 9px;
      transition: transform 0.2s;
      color: #999;
    }

    .sub-group-header .sub-arrow.open {
      transform: rotate(90deg);
    }

    .sub-group-header .sub-icon {
      font-size: 12px;
    }

    .sub-group-header .sub-count {
      margin-left: auto;
      font-weight: 400;
      font-size: 10px;
      color: #999;
    }

    .sub-items-container {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .sub-items-container.sub-collapsed {
      max-height: 0 !important;
    }

    /* ===== Accordion Toggle ===== */
    .group-toggle {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 11px;
      color: #666;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
      transition: color 0.2s;
    }

    .group-toggle:hover {
      color: #333;
    }

    .group-toggle .toggle-arrow {
      transition: transform 0.2s;
      font-size: 10px;
    }

    .group-toggle .toggle-arrow.open {
      transform: rotate(90deg);
    }

    .comment-items-container {
      overflow: hidden;
      transition: max-height 0.3s ease;
      max-height: none;
    }

    .comment-items-container.collapsed {
      max-height: 0 !important;
    }
  </style>
</head>

<body>

  <!-- Header -->
  <header class="header">
    <div class="logo">
      <div class="logo-icon">üí¨</div>
      <span class="logo-text">Comment Summarizer</span>
    </div>
    <div class="date-picker">
      <select class="date-select" id="dateRange">
        <option value="24h">ÏµúÍ∑º 24ÏãúÍ∞Ñ</option>
        <option value="3d">ÏµúÍ∑º 3Ïùº</option>
        <option value="1w">ÏµúÍ∑º 1Ï£ºÏùº</option>
        <option value="last">ÎßàÏßÄÎßâ Î∞©Î¨∏ Ïù¥ÌõÑ</option>
      </select>
    </div>
  </header>

  <!-- Tabs -->
  <div class="tabs">
    <button class="tab active" id="tabAll">
      Ï†ÑÏ≤¥ Î≥¥Í∏∞ <span class="tab-count">0</span>
    </button>
    <button class="tab" id="tabPending">
      ÎØ∏ÏôÑÎ£åÎßå <span class="tab-count">0</span>
    </button>
  </div>

  <!-- Content -->
  <main class="content">
    <!-- Empty State -->
    <div class="empty-state" id="emptyState">
      <div class="empty-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
        </svg>
      </div>
      <p class="empty-title">ÏΩîÎ©òÌä∏Í∞Ä ÏóÜÏäµÎãàÎã§</p>
      <p class="empty-desc">Í∏∞Í∞ÑÏùÑ ÏÑ†ÌÉùÌïòÍ≥† API ÌÇ§Î•º ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî</p>
    </div>

    <!-- Modern Loading Screen -->
    <div class="loading-screen" id="loadingScreen" style="display:none;">
      <div class="loading-spinner-ring">
        <svg viewBox="0 0 64 64">
          <defs>
            <linearGradient id="loadingGradient" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="#4285f4" />
              <stop offset="100%" stop-color="#18a0fb" />
            </linearGradient>
          </defs>
          <circle class="ring-bg" cx="32" cy="32" r="24" />
          <circle class="ring-fg" id="loadingRing" cx="32" cy="32" r="24" />
        </svg>
      </div>
      <div class="loading-step-text" id="loadingStepText">üóÇÔ∏è ÌîºÍ∑∏Îßà ÌååÏùº Ïä§Ï∫î Ï§ë...</div>
      <div class="loading-sub-text" id="loadingSubText"></div>
      <div class="loading-progress-wrap">
        <div class="loading-progress-bar">
          <div class="loading-progress-fill" id="loadingProgressFill"></div>
        </div>
        <div class="loading-progress-label" id="loadingProgressLabel"></div>
      </div>
    </div>

    <!-- Comment List (will be populated by JS) -->
    <div class="comment-list" id="commentList">
      <!-- Example structure for reference:
      <div class="comment-group">
        <div class="group-header">
          <span class="group-icon">üìÅ</span>
          <span>Home ÌôîÎ©¥</span>
        </div>
        <div class="comment-item">
          <div class="comment-content">
            <span class="comment-tag tag-change">ÏàòÏ†ï ÏöîÏ≤≠</span>
            <p class="comment-summary">Î°úÍ≥† ÌÅ¨Í∏∞Î•º 20% Ï§ÑÏó¨Ï£ºÏÑ∏Ïöî</p>
            <p class="comment-meta">@designer_kim ¬∑ 2ÏãúÍ∞Ñ Ï†Ñ</p>
          </div>
        </div>
      </div>
      -->
    </div>
  </main>

  <!-- Footer -->
  <footer class="footer">
    <button class="btn-settings" id="openSettings">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="3"></circle>
        <path
          d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
        </path>
      </svg>
      API ÌÇ§ ÏÑ§Ï†ï
      <span class="settings-status not-configured" id="settingsStatus">ÎØ∏ÏÑ§Ï†ï</span>
    </button>
  </footer>

  <!-- Toast Notification -->
  <div class="toast" id="toast"></div>

  <!-- Modal: API Settings -->
  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title">API ÌÇ§ ÏÑ§Ï†ï</h2>
      </div>
      <div class="modal-body">
        <div class="input-group">
          <label for="figmaFileUrl">Figma ÌååÏùº URL <span style="font-weight:400;color:#999;">(Î∏åÎùºÏö∞Ï†Ä Ï£ºÏÜåÏ∞ΩÏóêÏÑú
              Î≥µÏÇ¨)</span></label>
          <div class="input-wrapper">
            <input type="text" id="figmaFileUrl" placeholder="https://www.figma.com/design/ABC123.../...">
          </div>
        </div>
        <div class="input-group">
          <label for="figmaToken">Figma Personal Access Token</label>
          <div class="input-wrapper">
            <input type="password" id="figmaToken" placeholder="figd_xxx...">
            <button type="button" class="toggle-visibility" data-target="figmaToken" title="ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥¥Í∏∞">üëÅ</button>
          </div>
        </div>
        <div class="input-group">
          <label for="geminiKey">Gemini API Key</label>
          <div class="input-wrapper">
            <input type="password" id="geminiKey" placeholder="AIza... (Google AI StudioÏóêÏÑú Î¨¥Î£å Î∞úÍ∏â Í∞ÄÎä•)">
            <button type="button" class="toggle-visibility" data-target="geminiKey" title="ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥¥Í∏∞">üëÅ</button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancelSettings">Ï∑®ÏÜå</button>
        <button class="btn btn-primary" id="saveSettings">Ï†ÄÏû•</button>
      </div>
    </div>
  </div>

  <script>
    // DOM Elements
    const dateRangeSelect = document.getElementById('dateRange');
    const tabAll = document.getElementById('tabAll');
    const tabPending = document.getElementById('tabPending');
    const emptyState = document.getElementById('emptyState');
    const commentList = document.getElementById('commentList');
    const openSettingsBtn = document.getElementById('openSettings');
    const settingsModal = document.getElementById('settingsModal');
    const cancelSettingsBtn = document.getElementById('cancelSettings');
    const saveSettingsBtn = document.getElementById('saveSettings');
    const figmaTokenInput = document.getElementById('figmaToken');
    const geminiKeyInput = document.getElementById('geminiKey');
    const figmaFileUrlInput = document.getElementById('figmaFileUrl');
    const toast = document.getElementById('toast');
    const settingsStatus = document.getElementById('settingsStatus');
    const toggleButtons = document.querySelectorAll('.toggle-visibility');

    // Toast ÏïåÎ¶º ÌëúÏãú Ìï®Ïàò
    function showToast(message, type = 'default') {
      toast.textContent = message;
      toast.className = 'toast show ' + type;
      setTimeout(() => {
        toast.className = 'toast';
      }, 3000);
    }

    // ÏÑ§Ï†ï ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
    function updateSettingsStatus(hasSettings) {
      if (hasSettings) {
        settingsStatus.textContent = 'ÏÑ§Ï†ïÎê® ‚úì';
        settingsStatus.className = 'settings-status configured';
      } else {
        settingsStatus.textContent = 'ÎØ∏ÏÑ§Ï†ï';
        settingsStatus.className = 'settings-status not-configured';
      }
    }

    // Figma URLÏóêÏÑú fileKey Ï∂îÏ∂ú
    // ÏßÄÏõê ÌòïÏãù: /file/{key}/..., /design/{key}/..., /board/{key}/...
    function extractFileKeyFromUrl(url) {
      const match = url.match(/figma\.com\/(file|design|board)\/([a-zA-Z0-9]+)/);
      return match ? match[2] : null;
    }

    // Tab switching
    let currentFilter = 'all'; // 'all' | 'pending'
    let allClassifiedComments = []; // Î∂ÑÎ•òÎêú ÏΩîÎ©òÌä∏ Ï†ÑÏ≤¥ Ï†ÄÏû•
    let currentCheckedStates = {}; // Ï≤¥ÌÅ¨ ÏÉÅÌÉú

    tabAll.addEventListener('click', () => {
      tabAll.classList.add('active');
      tabPending.classList.remove('active');
      currentFilter = 'all';
      applyFilter();
    });

    tabPending.addEventListener('click', () => {
      tabPending.classList.add('active');
      tabAll.classList.remove('active');
      currentFilter = 'pending';
      applyFilter();
    });

    // Date range change
    dateRangeSelect.addEventListener('change', (e) => {
      const range = e.target.value;
      parent.postMessage({ pluginMessage: { type: 'date-range-changed', range } }, '*');
    });

    // Password visibility toggle
    toggleButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const targetId = btn.getAttribute('data-target');
        const input = document.getElementById(targetId);
        if (input.type === 'password') {
          input.type = 'text';
          btn.textContent = 'üôà';
          btn.title = 'ÎπÑÎ∞ÄÎ≤àÌò∏ Ïà®Í∏∞Í∏∞';
        } else {
          input.type = 'password';
          btn.textContent = 'üëÅ';
          btn.title = 'ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥¥Í∏∞';
        }
      });
    });

    // Settings modal
    openSettingsBtn.addEventListener('click', () => {
      settingsModal.classList.add('show');
    });

    cancelSettingsBtn.addEventListener('click', () => {
      settingsModal.classList.remove('show');
    });

    saveSettingsBtn.addEventListener('click', () => {
      const figmaToken = figmaTokenInput.value.trim();
      const geminiKey = geminiKeyInput.value.trim();
      const fileUrl = figmaFileUrlInput.value.trim();

      // Figma URLÏóêÏÑú fileKey Ï∂îÏ∂ú
      if (fileUrl) {
        const extractedKey = extractFileKeyFromUrl(fileUrl);
        if (extractedKey) {
          parent.postMessage({
            pluginMessage: { type: 'save-file-key', fileKey: extractedKey }
          }, '*');
          window.fileKey = extractedKey;
        } else {
          showToast('Figma URL ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.', 'error');
          return;
        }
      }

      parent.postMessage({
        pluginMessage: {
          type: 'save-api-keys',
          figmaToken,
          geminiKey
        }
      }, '*');
      settingsModal.classList.remove('show');
    });

    // Close modal when clicking overlay
    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) {
        settingsModal.classList.remove('show');
      }
    });

    // Receive messages from plugin code
    window.onmessage = (event) => {
      const message = event.data.pluginMessage;
      if (!message) return;

      switch (message.type) {
        case 'load-settings':
          // Pre-fill saved API keys
          if (message.figmaToken) figmaTokenInput.value = message.figmaToken;
          if (message.geminiKey) geminiKeyInput.value = message.geminiKey;
          // ÏÑ§Ï†ï ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
          updateSettingsStatus(message.hasSettings);
          break;

        case 'settings-saved':
          // Ï†ÄÏû• Í≤∞Í≥º Toast ÌëúÏãú
          showToast(message.message, message.success ? 'success' : 'error');
          if (message.success) {
            updateSettingsStatus(true);
          }
          break;

        case 'file-info':
          // ÌååÏùº Ï†ïÎ≥¥ Ï†ÄÏû•
          window.fileKey = message.fileKey;
          window.fileName = message.fileName;
          console.log('üìÅ ÌååÏùº Ï†ïÎ≥¥:', message.fileName, message.fileKey);
          // fileKeyÍ∞Ä ÏóÜÏúºÎ©¥ ÏÑ§Ï†ï Î™®Îã¨ ÏûêÎèô Ïò§Ìîà
          if (!message.fileKey) {
            console.log('‚ö†Ô∏è fileKeyÍ∞Ä ÏóÜÏäµÎãàÎã§. ÏÑ§Ï†ïÏóêÏÑú Figma ÌååÏùº URLÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
          }
          break;

        case 'file-key-saved':
          window.fileKey = message.fileKey;
          showToast('ÌååÏùº ÌÇ§ Ï†ÄÏû• ÏôÑÎ£å!', 'success');
          break;

        case 'fetch-comments-request':
          // code.tsÏóêÏÑú ÏöîÏ≤≠Ïù¥ Ïò§Î©¥ Ïã§Ï†ú API Ìò∏Ï∂ú ÏàòÌñâ
          fetchComments(message.fileKey, message.figmaToken, message.range, message.lastCheckTime);
          break;

        case 'zoom-failed':
          showToast(message.message, 'error');
          break;

        case 'fetch-error':
          // ÏóêÎü¨ ÌëúÏãú
          showToast(message.error, 'error');
          updateEmptyState('error', message.error);
          break;

        case 'comments-loaded':
          console.log(`üìã UIÏóêÏÑú ${message.count}Í∞ú ÏΩîÎ©òÌä∏ ÏàòÏã†`);
          currentCheckedStates = message.checkedStates || {};
          if (message.count === 0) {
            updateEmptyState('empty', 'Ìï¥Îãπ Í∏∞Í∞ÑÏóê ÏΩîÎ©òÌä∏Í∞Ä ÏóÜÏäµÎãàÎã§');
          } else {
            classifyAndRenderComments(message.comments);
          }
          break;
      }
    };

    // ===== Phase 1-2: Figma REST API ÏΩîÎ©òÌä∏ Ï°∞Ìöå =====

    // Í∏∞Í∞Ñ ÌïÑÌÑ∞ Í≥ÑÏÇ∞ Ìï®Ïàò
    function getDateFilter(range, lastCheckTime) {
      const now = new Date();
      let sinceDate;

      switch (range) {
        case '24h':
          sinceDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
          break;
        case '3d':
          sinceDate = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000);
          break;
        case '1w':
          sinceDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          break;
        case 'last':
          sinceDate = lastCheckTime ? new Date(lastCheckTime) : new Date(now.getTime() - 24 * 60 * 60 * 1000);
          break;
        default:
          sinceDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
      }

      return sinceDate.toISOString();
    }

    // ÏΩîÎ©òÌä∏ Ï°∞Ìöå Ìï®Ïàò
    async function fetchComments(fileKey, figmaToken, range, lastCheckTime) {
      // Î°úÎî© ÏÉÅÌÉú ÌëúÏãú
      updateEmptyState('loading', 'ÏΩîÎ©òÌä∏Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...');

      try {
        const response = await fetch(
          `https://api.figma.com/v1/files/${fileKey}/comments`,
          {
            method: 'GET',
            headers: {
              'X-Figma-Token': figmaToken
            }
          }
        );

        if (!response.ok) {
          let errorMessage = 'ÏΩîÎ©òÌä∏Î•º Í∞ÄÏ†∏Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.';
          if (response.status === 403) {
            errorMessage = 'API ÌÜ†ÌÅ∞Ïù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§. Îã§Ïãú ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî.';
          } else if (response.status === 404) {
            errorMessage = 'ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.';
          }
          throw new Error(errorMessage);
        }

        const data = await response.json();
        const allComments = data.comments || [];

        // Í∏∞Í∞Ñ ÌïÑÌÑ∞ÎßÅ
        const sinceDate = getDateFilter(range, lastCheckTime);
        const filteredComments = allComments.filter(comment => {
          return new Date(comment.created_at) >= new Date(sinceDate);
        });

        console.log(`üîç Ï†ÑÏ≤¥ ${allComments.length}Í∞ú Ï§ë ${filteredComments.length}Í∞ú ÌïÑÌÑ∞Îê® (${range})`);

        // code.tsÏóê Í≤∞Í≥º Ï†ÑÎã¨ (allCommentsÎäî Î∂ÄÎ™® ÏΩîÎ©òÌä∏ Îß§ÌïëÏö©)
        parent.postMessage({
          pluginMessage: {
            type: 'comments-fetched',
            comments: filteredComments,
            allCommentsForLookup: allComments
          }
        }, '*');

        // Î°úÎî© ÏôÑÎ£å Toast
        showToast(`${filteredComments.length}Í∞ú ÏΩîÎ©òÌä∏ Î°úÎìú ÏôÑÎ£å`, 'success');

      } catch (error) {
        console.error('‚ùå ÏΩîÎ©òÌä∏ Ï°∞Ìöå Ïã§Ìå®:', error);
        parent.postMessage({
          pluginMessage: {
            type: 'comments-fetch-error',
            error: error.message
          }
        }, '*');
      }
    }

    // Loading Screen ÏöîÏÜå
    const loadingScreen = document.getElementById('loadingScreen');
    const loadingStepText = document.getElementById('loadingStepText');
    const loadingSubText = document.getElementById('loadingSubText');
    const loadingProgressFill = document.getElementById('loadingProgressFill');
    const loadingProgressLabel = document.getElementById('loadingProgressLabel');
    const loadingRing = document.getElementById('loadingRing');

    let loadingStepTimer = null;

    // Î™®Îçò Î°úÎî© ÌôîÎ©¥ ÌëúÏãú
    function showLoadingScreen(totalFrames) {
      emptyState.style.display = 'none';
      commentList.style.display = 'none';
      loadingScreen.style.display = 'flex';

      // Step 1: ÌååÏùº Ïä§Ï∫î
      updateLoadingStep('üóÇÔ∏è ÌîºÍ∑∏Îßà ÌååÏùº Ïä§Ï∫î Ï§ë...', '', 0, totalFrames);

      // ÏûêÎèô Îã®Í≥Ñ Ï†ÑÌôò (Step 1 ‚Üí Step 2)
      loadingStepTimer = setTimeout(() => {
        updateLoadingStep('üí¨ Ï†ÑÏ≤¥ ÏΩîÎ©òÌä∏ ÏàòÏßë Ï§ë...', '', 0, totalFrames);
      }, 1500);
    }

    function updateLoadingStep(text, subText, current, total) {
      if (loadingStepText) {
        loadingStepText.classList.remove('fade-in-up');
        void loadingStepText.offsetWidth; // reflow
        loadingStepText.classList.add('fade-in-up');
        loadingStepText.textContent = text;
      }
      if (loadingSubText) loadingSubText.textContent = subText || '';
      if (total > 0) {
        const pct = Math.round((current / total) * 100);
        if (loadingProgressFill) loadingProgressFill.style.width = pct + '%';
        if (loadingProgressLabel) loadingProgressLabel.textContent = `${current} / ${total} ÌîÑÎ†àÏûÑ Î∂ÑÏÑù ÏôÑÎ£å`;
        // ÌîÑÎ°úÍ∑∏Î†àÏä§ ÎßÅ Ïó∞Îèô
        if (loadingRing) {
          const circumference = 2 * Math.PI * 24; // r=24
          const offset = circumference - (pct / 100) * circumference;
          loadingRing.style.strokeDasharray = circumference;
          loadingRing.style.strokeDashoffset = offset;
        }
      }
    }

    function hideLoadingScreen() {
      if (loadingStepTimer) clearTimeout(loadingStepTimer);
      loadingScreen.style.display = 'none';
    }

    // Empty State ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò (ÏóêÎü¨/Îπà ÏÉÅÌÉúÏö©)
    function updateEmptyState(state, message) {
      hideLoadingScreen();
      const emptyIcon = emptyState.querySelector('.empty-icon');
      const emptyTitle = emptyState.querySelector('.empty-title');
      const emptyDesc = emptyState.querySelector('.empty-desc');

      switch (state) {
        case 'loading':
          // Íµ¨Î≤ÑÏ†Ñ Ìò∏Ìôò: showLoadingScreenÏúºÎ°ú ÎåÄÏ≤¥Îê®
          emptyState.style.display = 'none';
          return;
        case 'error':
          emptyIcon.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#e53935" stroke-width="2">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="15" y1="9" x2="9" y2="15"></line>
              <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
          `;
          emptyTitle.textContent = 'Ïò§Î•ò Î∞úÏÉù';
          emptyDesc.textContent = message || '';
          break;
        case 'empty':
          emptyIcon.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
          `;
          emptyTitle.textContent = message || 'ÏΩîÎ©òÌä∏Í∞Ä ÏóÜÏäµÎãàÎã§';
          emptyDesc.textContent = 'Í∏∞Í∞ÑÏùÑ Î≥ÄÍ≤ΩÌï¥Î≥¥ÏÑ∏Ïöî';
          break;
        default:
          emptyIcon.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
          `;
          emptyTitle.textContent = 'ÏΩîÎ©òÌä∏Í∞Ä ÏóÜÏäµÎãàÎã§';
          emptyDesc.textContent = 'Í∏∞Í∞ÑÏùÑ ÏÑ†ÌÉùÌïòÍ≥† API ÌÇ§Î•º ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî';
      }
      emptyState.style.display = 'flex';
    }

    // ===== Gemini API ÌÜµÏã† Ìï®Ïàò (429 ÏûêÎèô Ïû¨ÏãúÎèÑ Ìè¨Ìï®) =====

    async function callGeminiAPI(geminiKey, promptText, maxRetries = 3) {
      const GEMINI_MODEL = 'gemini-2.0-flash';
      const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${geminiKey}`;

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{ parts: [{ text: promptText }] }],
            generationConfig: {
              temperature: 0.2,
              maxOutputTokens: 4096,
              responseMimeType: 'application/json'
            }
          })
        });

        if (response.ok) {
          const data = await response.json();
          const resultText = data.candidates?.[0]?.content?.parts?.[0]?.text;
          if (!resultText) throw new Error('Gemini ÏùëÎãµÏóêÏÑú Í≤∞Í≥ºÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
          return JSON.parse(resultText);
        }

        if (response.status === 429 && attempt < maxRetries) {
          const backoffSec = 5 * Math.pow(2, attempt); // 5Ï¥à, 10Ï¥à, 20Ï¥à
          console.warn(`‚è≥ 429 Rate Limit ‚Üí ${backoffSec}Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ (${attempt + 1}/${maxRetries})`);
          await sleep(backoffSec * 1000);
          continue;
        }

        let errorMessage = 'Gemini API Ìò∏Ï∂úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.';
        if (response.status === 400) errorMessage = 'Gemini API ÌÇ§Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§.';
        else if (response.status === 429) errorMessage = `API Ìò∏Ï∂ú ÌïúÎèÑ Ï¥àÍ≥º. ${maxRetries}Ìöå Ïû¨ÏãúÎèÑ Ïã§Ìå®.`;
        throw new Error(errorMessage);
      }
    }

    // ===== One-Shot ÌîÑÎ†àÏûÑÎ≥Ñ ÌÜµÌï© Ï≤òÎ¶¨ (Î∂ÑÎ•ò + ÏöîÏïΩ) =====

    const FRAME_DELAY_MS = 1000; // ÌîÑÎ†àÏûÑ Í∞Ñ 1Ï¥à ÎîúÎ†àÏù¥

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // ÏΩîÎ©òÌä∏Î•º leaf-frame Îã®ÏúÑÎ°ú Í∑∏Î£πÌïë (hierarchy ÎÅùÎã® Í∏∞Ï§Ä)
    function groupByLeafFrame(comments) {
      const frameGroups = {};
      comments.forEach(c => {
        const h = c.hierarchy || [];
        // leaf-frame key: hierarchy Ï†ÑÏ≤¥ Í≤ΩÎ°ú (Ïòà: "8-3. Digital Key > P-8300-1")
        const key = h.length > 1
          ? h.slice(1).map(a => a.name).join(' > ')
          : h.length === 1 ? h[0].name : 'Í∏∞ÌÉÄ';
        if (!frameGroups[key]) frameGroups[key] = [];
        frameGroups[key].push(c);
      });
      return frameGroups;
    }

    // ÏΩîÎ©òÌä∏Î•º Ïì∞Î†àÎìú Îã®ÏúÑÎ°ú Î¨∂Í∏∞
    function groupByThread(comments) {
      const threads = {};
      // Î∂ÄÎ™® ÏΩîÎ©òÌä∏ Î®ºÏ†Ä
      comments.filter(c => !c.isReply).forEach(c => {
        threads[c.id] = { parent: c, replies: [] };
      });
      // ÎãµÍ∏Ä Ï∂îÍ∞Ä
      comments.filter(c => c.isReply).forEach(c => {
        if (threads[c.threadId]) {
          threads[c.threadId].replies.push(c);
        } else {
          // Î∂ÄÎ™®Í∞Ä ÌïÑÌÑ∞ Î∞ñÏù¥Î©¥ ÎãµÍ∏ÄÏùÑ ÎèÖÎ¶Ω Ïì∞Î†àÎìúÎ°ú
          threads[c.threadId] = { parent: c, replies: [] };
        }
      });
      // ÏãúÍ∞ÑÏàú Ï†ïÎ†¨
      Object.values(threads).forEach(t => {
        t.replies.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
      });
      return threads;
    }

    // ÏöîÏïΩ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•ÏÜå: framePath ‚Üí { summary, classifiedComments }
    let allFrameSummaries = {};

    async function classifyAndRenderComments(comments) {
      const geminiKey = geminiKeyInput.value.trim();

      // API ÌÇ§ ÏóÜÏúºÎ©¥ Î∂ÑÎ•ò ÏóÜÏù¥ Î∞îÎ°ú Î†åÎçîÎßÅ
      if (!geminiKey) {
        allClassifiedComments = comments.map(comment => ({
          ...comment,
          category: 'discussion',
          priority: 'normal',
          summary: comment.message.substring(0, 30),
          checked: currentCheckedStates[comment.id] || false
        }));
        renderCommentList(allClassifiedComments);
        showToast('Gemini API ÌÇ§Í∞Ä ÏóÜÏñ¥ Î∂ÑÎ•ò ÏóÜÏù¥ ÌëúÏãúÌï©ÎãàÎã§.', 'error');
        return;
      }

      // Î™®Îçò Î°úÎî© ÌôîÎ©¥ ÌëúÏãú
      allClassifiedComments = comments.map(comment => ({
        ...comment,
        category: 'discussion',
        priority: 'normal',
        summary: comment.message.substring(0, 30),
        checked: currentCheckedStates[comment.id] || false
      }));
      allFrameSummaries = {};

      // leaf-frame Îã®ÏúÑÎ°ú Í∑∏Î£πÌïë
      const frameGroups = groupByLeafFrame(allClassifiedComments);
      const framePaths = Object.keys(frameGroups);
      console.log(`üöÄ ${framePaths.length}Í∞ú ÌîÑÎ†àÏûÑ(leaf) ÌÜµÌï© Ï≤òÎ¶¨ ÏãúÏûë`);

      showLoadingScreen(framePaths.length);

      let failedFrames = 0;

      for (let i = 0; i < framePaths.length; i++) {
        const framePath = framePaths[i];
        const frameComments = frameGroups[framePath];

        // Step 3: AI Î∂ÑÏÑù ÏßÑÌñâÎ•†
        updateLoadingStep(
          'üß† AIÍ∞Ä Ïä§Î†àÎìúÎ≥ÑÎ°ú Î∂ÑÎ•òÌïòÍ≥† ÏûàÏñ¥Ïöî...',
          framePath,
          i, framePaths.length
        );

        // ÏΩîÎ©òÌä∏ 1Í∞ú Ïù¥ÌïòÎ©¥ Í∞ÑÎã® Ï≤òÎ¶¨
        if (frameComments.length < 2) {
          const c = frameComments[0];
          allFrameSummaries[framePath] = {
            summary: {
              title: c.message.substring(0, 15),
              status: 'Open',
              issues: [],
              decisions: []
            },
            classifiedComments: [{
              id: c.id, category: 'discussion', priority: 'normal',
              summary: c.message.substring(0, 20)
            }]
          };
          applyFrameResult(framePath, allFrameSummaries[framePath], frameComments);
          continue;
        }

        try {
          // Ïì∞Î†àÎìú Íµ¨Ï°∞Î°ú ÌîÑÎ°¨ÌîÑÌä∏ ÏÉùÏÑ±
          const threads = groupByThread(frameComments);
          const prompt = buildThreadAwarePrompt(framePath, threads);
          const result = await callGeminiAPI(geminiKey, prompt);
          allFrameSummaries[framePath] = result;
          applyFrameResult(framePath, result, frameComments);
          console.log(`  ‚úÖ "${framePath}" ÏôÑÎ£å (${frameComments.length}Í∞ú ÏΩîÎ©òÌä∏, ${Object.keys(threads).length} Ïì∞Î†àÎìú)`);
        } catch (error) {
          console.warn(`  ‚ö†Ô∏è "${framePath}" Ïã§Ìå®:`, error.message);
          failedFrames++;
          allFrameSummaries[framePath] = {
            summary: { title: 'Î∂ÑÏÑù Ïã§Ìå®', status: 'Error', issues: ['AI ÏùëÎãµÏùÑ Î∞õÏïÑÏò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.'], decisions: [] },
            classifiedComments: []
          };
        }

        if (i < framePaths.length - 1) {
          await sleep(FRAME_DELAY_MS);
        }
      }

      // Step 4: ÏµúÏ¢Ö ÏöîÏïΩ
      updateLoadingStep('‚ú® ÏµúÏ¢Ö ÏöîÏïΩ ÏÉùÏÑ± Ï§ë! Í±∞Ïùò Îã§ ÎêêÏñ¥Ïöî.', '', framePaths.length, framePaths.length);
      await sleep(600);
      hideLoadingScreen();

      // ÏµúÏ¢Ö Î†åÎçîÎßÅ
      renderCommentList(allClassifiedComments);

      const successFrames = framePaths.length - failedFrames;
      if (failedFrames === 0) {
        showToast(`${framePaths.length}Í∞ú ÌîÑÎ†àÏûÑ Î∂ÑÏÑù ÏôÑÎ£å`, 'success');
      } else {
        showToast(`${successFrames}/${framePaths.length} ÌîÑÎ†àÏûÑ ÏÑ±Í≥µ, ${failedFrames}Í∞ú Ïã§Ìå®`, 'error');
      }
    }

    // ÌîÑÎ†àÏûÑ Í≤∞Í≥ºÎ•º allClassifiedCommentsÏóê Î∞òÏòÅ
    function applyFrameResult(framePath, result, frameComments) {
      const classified = result.classifiedComments || [];
      frameComments.forEach(comment => {
        const match = classified.find(c => c.id === comment.id);
        if (match) {
          const idx = allClassifiedComments.findIndex(c => c.id === comment.id);
          if (idx !== -1) {
            allClassifiedComments[idx].category = match.category || 'discussion';
            allClassifiedComments[idx].priority = match.priority || 'normal';
            allClassifiedComments[idx].summary = match.summary || comment.message.substring(0, 20);
          }
        }
      });
    }

    function buildThreadAwarePrompt(framePath, threads) {
      // Ïì∞Î†àÎìú Íµ¨Ï°∞Î°ú ÏΩîÎ©òÌä∏ Ï†ïÎ¶¨
      const threadList = Object.values(threads).map(t => {
        const parentMsg = `[Î∂ÄÎ™®] "${t.parent.user?.handle || 'unknown'}": "${t.parent.message.replace(/"/g, '\\"').replace(/\n/g, ' ').substring(0, 300)}"`;
        const replies = t.replies.map(r =>
          `  [ÎãµÍ∏Ä] "${r.user?.handle || 'unknown'}": "${r.message.replace(/"/g, '\\"').replace(/\n/g, ' ').substring(0, 200)}"`
        ).join('\n');
        const ids = [t.parent.id, ...t.replies.map(r => r.id)].join(',');
        return `Ïì∞Î†àÎìú(ids:${ids}):\n${parentMsg}${replies ? '\n' + replies : ''}`;
      }).join('\n\n');

      return `ÏïÑÎûòÎäî Figma ÌîÑÎ†àÏûÑ "${framePath}"Ïóê Îã¨Î¶∞ ÏΩîÎ©òÌä∏ ÎåÄÌôîÏûÖÎãàÎã§.
Ïì∞Î†àÎìú(Î∂ÄÎ™®+ÎãµÍ∏Ä) Îã®ÏúÑÎ°ú Ï†ïÎ¶¨ÎêòÏñ¥ ÏûàÏäµÎãàÎã§.

[Ïì∞Î†àÎìú Î™©Î°ù]
${threadList}

=== Î∂ÑÏÑù ÏöîÏ≤≠ ===
1) summary: Ïù¥ ÌîÑÎ†àÏûÑÏùò Ï†ÑÏ≤¥ ÎåÄÌôîÎ•º ÌïúÍµ≠Ïñ¥Î°ú ÏöîÏïΩ
2) classifiedComments: Í∞Å ÏΩîÎ©òÌä∏Î•º Î∂ÑÎ•ò (Î∂ÄÎ™®+ÎãµÍ∏Ä Î™®Îëê)

JSON ÌòïÏãùÏúºÎ°úÎßå ÏùëÎãµ:
{
  "summary": {
    "title": "ÌïµÏã¨ Ï£ºÏ†ú 15ÏûêÏù¥ÎÇ¥",
    "status": "Open ÎòêÎäî Resolved",
    "issues": ["Ï£ºÏöî Ïù¥Ïäà (ÌïúÍµ≠Ïñ¥)"],
    "decisions": ["Í≤∞Ï†ï/ÏôÑÎ£åÎêú Í≤É (ÌïúÍµ≠Ïñ¥)"]
  },
  "classifiedComments": [
    {"id":"ÏõêÎ≥∏id","category":"bug|change_request|question|discussion","priority":"urgent|normal","summary":"ÌïúÍµ≠Ïñ¥ ÌïúÏ§ÑÏöîÏïΩ 20ÏûêÏù¥ÎÇ¥"}
  ]
}`;
    }

    // ===== Phase 1-4: UI Î†åÎçîÎßÅ =====

    const CATEGORY_MAP = {
      bug: { label: 'Î≤ÑÍ∑∏', cssClass: 'tag-bug', icon: 'üî¥' },
      change_request: { label: 'ÏàòÏ†ï ÏöîÏ≤≠', cssClass: 'tag-change', icon: 'üü†' },
      question: { label: 'ÏßàÎ¨∏', cssClass: 'tag-question', icon: 'üîµ' },
      discussion: { label: 'ÎÖºÏùò', cssClass: 'tag-feedback', icon: '‚ö™' }
    };

    function renderCommentList(comments) {
      // ÌïÑÌÑ∞ Ï†ÅÏö©
      let filtered = comments;
      if (currentFilter === 'pending') {
        filtered = comments.filter(c => !c.resolved_at);
      }

      // Level 1: ÏµúÏÉÅÏúÑ SectionÎ≥Ñ Í∑∏Î£πÌïë
      const sectionGroups = {};
      filtered.forEach(comment => {
        const key = comment.frameName || 'Í∏∞ÌÉÄ';
        if (!sectionGroups[key]) sectionGroups[key] = [];
        sectionGroups[key].push(comment);
      });

      const sortedSections = Object.keys(sectionGroups).sort((a, b) => sectionGroups[b].length - sectionGroups[a].length);

      if (sortedSections.length === 0) {
        emptyState.style.display = 'flex';
        commentList.style.display = 'none';
        updateEmptyState('empty', currentFilter === 'pending' ? 'ÎØ∏ÏôÑÎ£å ÏΩîÎ©òÌä∏Í∞Ä ÏóÜÏäµÎãàÎã§' : 'Ìï¥Îãπ Í∏∞Í∞ÑÏóê ÏΩîÎ©òÌä∏Í∞Ä ÏóÜÏäµÎãàÎã§');
        updateTabCounts(comments);
        return;
      }

      let html = '';
      let globalIdx = 0;

      sortedSections.forEach(sectionName => {
        const sectionComments = sectionGroups[sectionName];

        // Section Ìó§Îçî (category badges)
        const categoryCounts = {};
        sectionComments.forEach(c => {
          categoryCounts[c.category] = (categoryCounts[c.category] || 0) + 1;
        });
        const categoryBadges = Object.entries(categoryCounts)
          .map(([cat, count]) => `${CATEGORY_MAP[cat]?.icon || '‚ö™'} ${count}`)
          .join(' ');

        html += `<div class="comment-group">`;
        html += `<div class="group-header">
          <span class="group-icon">üìÅ</span>
          <span>${sectionName}</span>
          <span style="margin-left:auto; font-size:10px; color:#999; font-weight:400;">${categoryBadges}</span>
        </div>`;

        // Level 1 ÏïÑÏΩîÎîîÏñ∏ ÌÜ†Í∏Ä
        html += `<button class="group-toggle" data-frame="${sectionName}">
          <span class="toggle-arrow">‚ñ∂</span> ÏΩîÎ©òÌä∏ ${sectionComments.length}Í±¥ Î≥¥Í∏∞
        </button>`;

        html += `<div class="comment-items-container collapsed" data-frame-items="${sectionName}">`;

        // Level 2: Sub-SectionÎ≥Ñ Í∑∏Î£πÌïë (hierarchy[1])
        const subSectionGroups = {};
        sectionComments.forEach(c => {
          const h = c.hierarchy || [];
          const subKey = h.length > 1 ? h[1].name : 'ÏùºÎ∞ò';
          if (!subSectionGroups[subKey]) subSectionGroups[subKey] = [];
          subSectionGroups[subKey].push(c);
        });

        const subSectionKeys = Object.keys(subSectionGroups).sort((a, b) => {
          if (a === 'ÏùºÎ∞ò') return 1;
          if (b === 'ÏùºÎ∞ò') return -1;
          return subSectionGroups[b].length - subSectionGroups[a].length;
        });

        const hasMultipleSubs = subSectionKeys.length > 1 || (subSectionKeys.length === 1 && subSectionKeys[0] !== 'ÏùºÎ∞ò');

        subSectionKeys.forEach(subName => {
          const subComments = subSectionGroups[subName];
          const subId = `sub_${globalIdx++}`;

          // Level 2 Ìó§Îçî (Sub-Section)
          if (hasMultipleSubs && subName !== 'ÏùºÎ∞ò') {
            html += `<div class="frame-header" data-frame-id="${subId}">
              <span class="frame-arrow open">‚ñ∂</span>
              <span>üìÇ</span>
              <span>${subName}</span>
              <span class="frame-count">${subComments.length}Í±¥</span>
            </div>`;
          } else if (hasMultipleSubs && subName === 'ÏùºÎ∞ò') {
            html += `<div class="frame-header" data-frame-id="${subId}">
              <span class="frame-arrow open">‚ñ∂</span>
              <span>üìé</span>
              <span>Í∏∞ÌÉÄ ÏΩîÎ©òÌä∏</span>
              <span class="frame-count">${subComments.length}Í±¥</span>
            </div>`;
          }

          if (hasMultipleSubs) {
            html += `<div class="frame-items-container" data-frame-items-id="${subId}">`;
          }

          // Level 3: FrameÎ≥Ñ Í∑∏Î£πÌïë (hierarchy[2:])
          const frameGroups = {};
          subComments.forEach(c => {
            const h = c.hierarchy || [];
            const frameKey = h.length > 2
              ? h.slice(2).map(a => a.name).join(' > ')
              : 'ÏùºÎ∞ò';
            if (!frameGroups[frameKey]) frameGroups[frameKey] = [];
            frameGroups[frameKey].push(c);
          });

          const frameKeys = Object.keys(frameGroups).sort((a, b) => {
            if (a === 'ÏùºÎ∞ò') return 1;
            if (b === 'ÏùºÎ∞ò') return -1;
            return frameGroups[b].length - frameGroups[a].length;
          });

          const hasMultipleFrames = frameKeys.length > 1 || (frameKeys.length === 1 && frameKeys[0] !== 'ÏùºÎ∞ò');

          frameKeys.forEach(frameName => {
            const frameComments = frameGroups[frameName];
            const frameId = `frame_${globalIdx++}`;

            // Level 3 Ìó§Îçî (Frame)
            if (hasMultipleFrames && frameName !== 'ÏùºÎ∞ò') {
              html += `<div class="frame-header" data-frame-id="${frameId}" style="padding-left:20px;">
                <span class="frame-arrow open">‚ñ∂</span>
                <span>üñº</span>
                <span>${frameName}</span>
                <span class="frame-count">${frameComments.length}Í±¥</span>
              </div>`;
            }

            if (hasMultipleFrames) {
              html += `<div class="frame-items-container" data-frame-items-id="${frameId}">`;
            }

            // Frame-level AI ÏöîÏïΩ Ïπ¥Îìú
            const summaryKey = subName !== 'ÏùºÎ∞ò' && frameName !== 'ÏùºÎ∞ò'
              ? `${subName} > ${frameName}`
              : subName !== 'ÏùºÎ∞ò' ? subName : frameName;
            const frameData = allFrameSummaries[summaryKey];
            const summary = frameData?.summary;
            if (summary && summary.title !== 'Î∂ÑÏÑù Ïã§Ìå®') {
              const statusColor = summary.status === 'Resolved' ? '#4caf50' : '#fb8c00';
              const statusLabel = summary.status === 'Resolved' ? '‚úÖ Ìï¥Í≤∞Îê®' : 'üîÑ ÏßÑÌñâ Ï§ë';
              html += `<div class="summary-card">`;
              html += `<div class="summary-card-title">üí° ${summary.title} <span style="font-size:10px;color:${statusColor};margin-left:6px;">${statusLabel}</span></div>`;
              if (summary.issues?.length) html += summary.issues.map(i => `<div class="summary-card-section"><span class="section-icon">üìå</span>${i}</div>`).join('');
              if (summary.decisions?.length) html += summary.decisions.map(d => `<div class="summary-card-section"><span class="section-icon">‚úÖ</span>${d}</div>`).join('');
              html += `</div>`;
            } else if (summary && summary.title === 'Î∂ÑÏÑù Ïã§Ìå®') {
              html += `<div class="summary-card" style="background:#fff5f5; border-color:#ffcdd2;">`;
              html += `<div class="summary-card-title" style="color:#d32f2f;">üö´ Î∂ÑÏÑù Ïã§Ìå®</div>`;
              if (summary.issues?.length) html += `<div class="summary-card-section">${summary.issues[0]}</div>`;
              html += `</div>`;
            } else if (!frameData) {
              html += `<div class="summary-card"><span class="summary-card-loading">üí° ÏöîÏïΩ ÏÉùÏÑ± Ï§ë...</span></div>`;
            }

            // Ïì∞Î†àÎìú Îã®ÏúÑ Î†åÎçîÎßÅ
            const threads = groupByThread(frameComments);
            const threadEntries = Object.values(threads).sort((a, b) => {
              if (a.parent.priority === 'urgent' && b.parent.priority !== 'urgent') return -1;
              if (b.parent.priority === 'urgent' && a.parent.priority !== 'urgent') return 1;
              return new Date(b.parent.created_at) - new Date(a.parent.created_at);
            });

            threadEntries.forEach(thread => {
              const p = thread.parent;
              const cat = CATEGORY_MAP[p.category] || CATEGORY_MAP.discussion;
              const nodeId = p.resolvedNodeId || p.client_meta?.node_id || '';
              const urgentBadge = p.priority === 'urgent'
                ? '<span style="background:#ffebee;color:#e53935;padding:1px 5px;border-radius:3px;font-size:9px;font-weight:600;margin-left:4px;">Í∏¥Í∏â</span>'
                : '';
              const replyCount = thread.replies.length;
              const threadId = `thread_${p.threadId || p.id}`;

              html += `<div class="thread-card" data-thread-id="${threadId}">`;

              // Ïì∞Î†àÎìú Ìó§Îìú (Î∂ÄÎ™® ÏΩîÎ©òÌä∏)
              html += `<div class="thread-head" data-node-id="${nodeId}">
                <div class="comment-content">
                  <span class="comment-tag ${cat.cssClass}">${cat.label}</span>${urgentBadge}
                  <p class="comment-summary">${p.summary || p.message.substring(0, 40)}</p>
                  <p class="comment-meta">@${p.user?.handle || 'unknown'} ¬∑ ${formatRelativeTime(p.created_at)}</p>
                  ${replyCount > 0 ? `<p class="thread-reply-badge">üí¨ ${replyCount}Í∞ú ÎãµÍ∏Ä ¬∑ ÌÅ¥Î¶≠ÌïòÏó¨ ÌéºÏπòÍ∏∞</p>` : ''}
                </div>
              </div>`;

              // ÎãµÍ∏Ä Î¶¨Ïä§Ìä∏ (Í∏∞Î≥∏ Ï†ëÌûå ÏÉÅÌÉú)
              if (replyCount > 0) {
                html += `<div class="thread-replies" data-thread-replies="${threadId}">`;
                thread.replies.forEach(r => {
                  html += `<div class="thread-reply-item" data-node-id="${r.resolvedNodeId || ''}" data-comment-id="${r.id}">
                    <div>
                      <div class="reply-msg">${r.summary || r.message.substring(0, 60)}</div>
                      <div class="reply-meta">@${r.user?.handle || 'unknown'} ¬∑ ${formatRelativeTime(r.created_at)}</div>
                    </div>
                  </div>`;
                });
                html += `</div>`;
              }

              html += `</div>`; // thread-card
            });

            if (hasMultipleFrames) {
              html += `</div>`; // frame-items-container (Level 3)
            }
          });

          if (hasMultipleSubs) {
            html += `</div>`; // frame-items-container (Level 2)
          }
        });

        html += `</div>`; // comment-items-container (Level 1)
        html += `</div>`; // comment-group
      });

      commentList.innerHTML = html;
      emptyState.style.display = 'none';
      commentList.style.display = 'block';

      updateTabCounts(comments);
      attachCommentEvents();
    }

    function attachCommentEvents() {
      // Helper to toggle height with animation
      const toggleHeight = (container, isCollapsed, collapseClass) => {
        if (isCollapsed) {
          // Expand: 0 -> scrollHeight -> none
          container.classList.remove(collapseClass);
          container.style.maxHeight = container.scrollHeight + 'px';

          // Wait for transition to finish, then remove limit
          setTimeout(() => {
            if (!container.classList.contains(collapseClass)) {
              container.style.maxHeight = 'none';
              container.style.overflow = 'visible'; // Optional: allows dropdowns/tooltips to escape
            }
          }, 350);
        } else {
          // Collapse: none -> scrollHeight -> 0
          container.style.maxHeight = container.scrollHeight + 'px';
          container.style.overflow = 'hidden';
          // Force reflow
          void container.offsetHeight;

          requestAnimationFrame(() => {
            container.classList.add(collapseClass);
            container.style.maxHeight = '0';
          });
        }
      };

      // Level 1: Section ÏïÑÏΩîÎîîÏñ∏ ÌÜ†Í∏Ä
      commentList.querySelectorAll('.group-toggle').forEach(btn => {
        btn.addEventListener('click', () => {
          const frameName = btn.getAttribute('data-frame');
          const container = commentList.querySelector(`[data-frame-items="${frameName}"]`);
          const arrow = btn.querySelector('.toggle-arrow');
          if (!container) return;

          const isCollapsed = container.classList.contains('collapsed');
          toggleHeight(container, isCollapsed, 'collapsed');

          if (isCollapsed) {
            arrow.classList.add('open');
            btn.innerHTML = `<span class="toggle-arrow open">‚ñ∂</span> ÏΩîÎ©òÌä∏ Ï†ëÍ∏∞`;
          } else {
            arrow.classList.remove('open');
            const count = container.querySelectorAll('.thread-card').length;
            btn.innerHTML = `<span class="toggle-arrow">‚ñ∂</span> ÏΩîÎ©òÌä∏ ${count}Í±¥ Î≥¥Í∏∞`;
          }
        });
      });

      // Level 2/3: Sub-Section, Frame Í∑∏Î£π ÌÜ†Í∏Ä
      commentList.querySelectorAll('.frame-header').forEach(header => {
        header.addEventListener('click', () => {
          const frameId = header.getAttribute('data-frame-id');
          const container = commentList.querySelector(`[data-frame-items-id="${frameId}"]`);
          const arrow = header.querySelector('.frame-arrow');
          if (!container) return;

          const isCollapsed = container.classList.contains('frame-collapsed');
          toggleHeight(container, isCollapsed, 'frame-collapsed');

          if (arrow) {
            if (isCollapsed) arrow.classList.add('open');
            else arrow.classList.remove('open');
          }
        });
      });

      // Ïì∞Î†àÎìú ÌÅ¥Î¶≠ ‚Üí ÎãµÍ∏Ä ÌéºÏπ® + Ï§åÏù∏
      commentList.querySelectorAll('.thread-head').forEach(head => {
        head.addEventListener('click', (e) => {
          const threadCard = head.closest('.thread-card');
          const repliesContainer = threadCard?.querySelector('.thread-replies');

          // ÎãµÍ∏Ä ÌÜ†Í∏Ä (Custom logic for thread replies simpler transition)
          if (repliesContainer) {
            const isOpen = repliesContainer.classList.contains('thread-open');

            if (!isOpen) {
              // Expand
              repliesContainer.classList.add('thread-open');
              repliesContainer.style.maxHeight = repliesContainer.scrollHeight + 'px';
              setTimeout(() => {
                if (repliesContainer.classList.contains('thread-open')) repliesContainer.style.maxHeight = 'none';
              }, 350);
            } else {
              // Collapse
              repliesContainer.style.maxHeight = repliesContainer.scrollHeight + 'px';
              void repliesContainer.offsetHeight;
              requestAnimationFrame(() => {
                repliesContainer.classList.remove('thread-open');
                repliesContainer.style.maxHeight = '0';
              });
            }

            const badge = head.querySelector('.thread-reply-badge');
            if (badge) {
              badge.textContent = !isOpen
                ? 'üí¨ ÎãµÍ∏Ä Ï†ëÍ∏∞'
                : `üí¨ ${repliesContainer.querySelectorAll('.thread-reply-item').length}Í∞ú ÎãµÍ∏Ä ¬∑ ÌÅ¥Î¶≠ÌïòÏó¨ ÌéºÏπòÍ∏∞`;
            }
          }

          // Ï§åÏù∏
          const nodeId = head.getAttribute('data-node-id');
          if (nodeId) {
            window.parent.postMessage({
              pluginMessage: { type: 'zoom-to-node', nodeId }
            }, '*');
          }

          // No need for recalcAllAncestors with max-height: none strategy
        });
      });
    }

    function formatRelativeTime(dateStr) {
      const diff = Date.now() - new Date(dateStr).getTime();
      const minutes = Math.floor(diff / 60000);
      if (minutes < 1) return 'Î∞©Í∏à';
      if (minutes < 60) return `${minutes}Î∂Ñ Ï†Ñ`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}ÏãúÍ∞Ñ Ï†Ñ`;
      const days = Math.floor(hours / 24);
      if (days < 7) return `${days}Ïùº Ï†Ñ`;
      return new Date(dateStr).toLocaleDateString('ko-KR');
    }

    function updateTabCounts(comments) {
      const total = comments.length;
      const pending = comments.filter(c => !c.resolved_at).length;
      tabAll.querySelector('.tab-count').textContent = total;
      tabPending.querySelector('.tab-count').textContent = pending;
    }

    function applyFilter() {
      if (allClassifiedComments.length > 0) {
        renderCommentList(allClassifiedComments);
      }
    }
  </script>
</body>

</html>