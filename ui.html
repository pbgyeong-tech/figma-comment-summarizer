<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comment Summarizer</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 12px;
      color: #333;
      background-color: #fff;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* ===== Header ===== */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #e5e5e5;
      background-color: #fafafa;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .logo-icon {
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, #18a0fb 0%, #0d8de5 100%);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      font-weight: 600;
    }

    .logo-text {
      font-size: 13px;
      font-weight: 600;
      color: #1a1a1a;
    }

    .date-picker {
      position: relative;
    }

    .date-select {
      padding: 6px 28px 6px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 11px;
      font-family: 'Inter', sans-serif;
      background-color: #fff;
      color: #333;
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23666' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
    }

    .date-select:focus {
      outline: none;
      border-color: #18a0fb;
    }

    /* ===== Tabs ===== */
    .tabs {
      display: flex;
      border-bottom: 1px solid #e5e5e5;
      background-color: #fff;
    }

    .tab {
      flex: 1;
      padding: 10px 16px;
      font-size: 11px;
      font-weight: 500;
      color: #666;
      background: none;
      border: none;
      cursor: pointer;
      position: relative;
      transition: color 0.2s;
    }

    .tab:hover {
      color: #333;
    }

    .tab.active {
      color: #18a0fb;
    }

    .tab.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      right: 0;
      height: 2px;
      background-color: #18a0fb;
    }

    .tab-count {
      display: inline-block;
      margin-left: 4px;
      padding: 2px 6px;
      background-color: #f0f0f0;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 500;
      color: #666;
    }

    .tab.active .tab-count {
      background-color: #e3f2fd;
      color: #18a0fb;
    }

    /* ===== Content Area ===== */
    .content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #999;
      text-align: center;
    }

    .empty-icon {
      width: 48px;
      height: 48px;
      background-color: #f5f5f5;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 12px;
    }

    .empty-icon svg {
      width: 24px;
      height: 24px;
      stroke: #ccc;
    }

    .empty-title {
      font-size: 13px;
      font-weight: 500;
      color: #666;
      margin-bottom: 4px;
    }

    .empty-desc {
      font-size: 11px;
      color: #999;
    }

    /* ===== Comment List (placeholder) ===== */
    .comment-list {
      display: none;
    }

    .comment-group {
      margin-bottom: 16px;
    }

    .group-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 0;
      font-size: 12px;
      font-weight: 600;
      color: #333;
    }

    .group-icon {
      font-size: 14px;
    }

    .comment-item {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 12px;
      background-color: #fafafa;
      border-radius: 8px;
      margin-bottom: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .comment-item:hover {
      background-color: #f0f0f0;
    }

    .comment-checkbox {
      margin-top: 2px;
      width: 16px;
      height: 16px;
      accent-color: #18a0fb;
    }

    .comment-content {
      flex: 1;
    }

    .comment-tag {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
      margin-bottom: 4px;
    }

    .tag-bug {
      background-color: #ffebee;
      color: #e53935;
    }

    .tag-change {
      background-color: #fff3e0;
      color: #fb8c00;
    }

    .tag-question {
      background-color: #e3f2fd;
      color: #1e88e5;
    }

    .tag-feedback {
      background-color: #f5f5f5;
      color: #757575;
    }

    .comment-summary {
      font-size: 12px;
      color: #333;
      line-height: 1.4;
    }

    .comment-meta {
      font-size: 10px;
      color: #999;
      margin-top: 4px;
    }

    /* ===== Footer ===== */
    .footer {
      padding: 12px 16px;
      border-top: 1px solid #e5e5e5;
      background-color: #fafafa;
    }

    .btn-settings {
      width: 100%;
      padding: 10px 16px;
      border: 1px solid #ddd;
      border-radius: 6px;
      background-color: #fff;
      font-size: 11px;
      font-weight: 500;
      font-family: 'Inter', sans-serif;
      color: #666;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .btn-settings:hover {
      border-color: #18a0fb;
      color: #18a0fb;
    }

    .btn-settings svg {
      width: 14px;
      height: 14px;
    }

    /* ===== Modal (API Settings) ===== */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.4);
      z-index: 100;
    }

    .modal-overlay.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal {
      background-color: #fff;
      border-radius: 8px;
      width: 280px;
      max-width: 90%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    }

    .modal-header {
      padding: 16px;
      border-bottom: 1px solid #e5e5e5;
    }

    .modal-title {
      font-size: 14px;
      font-weight: 600;
      color: #1a1a1a;
    }

    .modal-body {
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .input-group label {
      font-size: 11px;
      font-weight: 500;
      color: #666;
    }

    .input-group input {
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 11px;
      font-family: 'Inter', sans-serif;
    }

    .input-group input:focus {
      outline: none;
      border-color: #18a0fb;
    }

    .modal-footer {
      padding: 12px 16px;
      border-top: 1px solid #e5e5e5;
      display: flex;
      gap: 8px;
    }

    .btn {
      flex: 1;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 500;
      font-family: 'Inter', sans-serif;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary {
      background-color: #18a0fb;
      color: white;
      border: none;
    }

    .btn-primary:hover {
      background-color: #0d8de5;
    }

    .btn-secondary {
      background-color: #fff;
      color: #666;
      border: 1px solid #ddd;
    }

    .btn-secondary:hover {
      background-color: #f5f5f5;
    }

    /* ===== Toast Notification ===== */
    .toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background-color: #333;
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
      z-index: 200;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .toast.show {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }

    .toast.success {
      background-color: #4caf50;
    }

    .toast.error {
      background-color: #e53935;
    }

    /* ===== Settings Status Badge ===== */
    .settings-status {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: 6px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
    }

    .settings-status.configured {
      background-color: #e8f5e9;
      color: #4caf50;
    }

    .settings-status.not-configured {
      background-color: #fff3e0;
      color: #fb8c00;
    }

    /* ===== Password Toggle ===== */
    .input-wrapper {
      position: relative;
      display: flex;
      align-items: center;
    }

    .input-wrapper input {
      width: 100%;
      padding-right: 36px;
    }

    .toggle-visibility {
      position: absolute;
      right: 8px;
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      color: #999;
      font-size: 14px;
      line-height: 1;
      transition: color 0.2s;
    }

    .toggle-visibility:hover {
      color: #333;
    }

    /* ===== Spinner Animation ===== */
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    .spinner {
      animation: spin 1s linear infinite;
    }

    /* ===== Smart Summary Card ===== */
    .summary-card {
      background: linear-gradient(135deg, #f0f4ff 0%, #e8f0fe 100%);
      border: 1px solid #d2e3fc;
      border-radius: 8px;
      padding: 10px 12px;
      margin: 6px 12px 4px;
      font-size: 11px;
      line-height: 1.6;
    }

    .summary-card-title {
      font-weight: 600;
      font-size: 12px;
      margin-bottom: 6px;
      color: #1a73e8;
    }

    .summary-card-section {
      margin: 3px 0;
      color: #333;
    }

    .summary-card-section .section-icon {
      margin-right: 4px;
    }

    .summary-card-loading {
      color: #999;
      font-style: italic;
      padding: 8px 12px;
      font-size: 11px;
    }

    /* ===== Accordion Toggle ===== */
    .group-toggle {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 11px;
      color: #666;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
      transition: color 0.2s;
    }

    .group-toggle:hover {
      color: #333;
    }

    .group-toggle .toggle-arrow {
      transition: transform 0.2s;
      font-size: 10px;
    }

    .group-toggle .toggle-arrow.open {
      transform: rotate(90deg);
    }

    .comment-items-container {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .comment-items-container.collapsed {
      max-height: 0 !important;
    }
  </style>
</head>

<body>

  <!-- Header -->
  <header class="header">
    <div class="logo">
      <div class="logo-icon">ğŸ’¬</div>
      <span class="logo-text">Comment Summarizer</span>
    </div>
    <div class="date-picker">
      <select class="date-select" id="dateRange">
        <option value="24h">ìµœê·¼ 24ì‹œê°„</option>
        <option value="3d">ìµœê·¼ 3ì¼</option>
        <option value="1w">ìµœê·¼ 1ì£¼ì¼</option>
        <option value="last">ë§ˆì§€ë§‰ ë°©ë¬¸ ì´í›„</option>
      </select>
    </div>
  </header>

  <!-- Tabs -->
  <div class="tabs">
    <button class="tab active" id="tabAll">
      ì „ì²´ ë³´ê¸° <span class="tab-count">0</span>
    </button>
    <button class="tab" id="tabPending">
      ë¯¸ì™„ë£Œë§Œ <span class="tab-count">0</span>
    </button>
  </div>

  <!-- Content -->
  <main class="content">
    <!-- Empty State -->
    <div class="empty-state" id="emptyState">
      <div class="empty-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
        </svg>
      </div>
      <p class="empty-title">ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤</p>
      <p class="empty-desc">ê¸°ê°„ì„ ì„ íƒí•˜ê³  API í‚¤ë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”</p>
    </div>

    <!-- Comment List (will be populated by JS) -->
    <div class="comment-list" id="commentList">
      <!-- Example structure for reference:
      <div class="comment-group">
        <div class="group-header">
          <span class="group-icon">ğŸ“</span>
          <span>Home í™”ë©´</span>
        </div>
        <div class="comment-item">
          <input type="checkbox" class="comment-checkbox">
          <div class="comment-content">
            <span class="comment-tag tag-change">ìˆ˜ì • ìš”ì²­</span>
            <p class="comment-summary">ë¡œê³  í¬ê¸°ë¥¼ 20% ì¤„ì—¬ì£¼ì„¸ìš”</p>
            <p class="comment-meta">@designer_kim Â· 2ì‹œê°„ ì „</p>
          </div>
        </div>
      </div>
      -->
    </div>
  </main>

  <!-- Footer -->
  <footer class="footer">
    <button class="btn-settings" id="openSettings">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="3"></circle>
        <path
          d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
        </path>
      </svg>
      API í‚¤ ì„¤ì •
      <span class="settings-status not-configured" id="settingsStatus">ë¯¸ì„¤ì •</span>
    </button>
  </footer>

  <!-- Toast Notification -->
  <div class="toast" id="toast"></div>

  <!-- Modal: API Settings -->
  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title">API í‚¤ ì„¤ì •</h2>
      </div>
      <div class="modal-body">
        <div class="input-group">
          <label for="figmaFileUrl">Figma íŒŒì¼ URL <span style="font-weight:400;color:#999;">(ë¸Œë¼ìš°ì € ì£¼ì†Œì°½ì—ì„œ
              ë³µì‚¬)</span></label>
          <div class="input-wrapper">
            <input type="text" id="figmaFileUrl" placeholder="https://www.figma.com/design/ABC123.../...">
          </div>
        </div>
        <div class="input-group">
          <label for="figmaToken">Figma Personal Access Token</label>
          <div class="input-wrapper">
            <input type="password" id="figmaToken" placeholder="figd_xxx...">
            <button type="button" class="toggle-visibility" data-target="figmaToken" title="ë¹„ë°€ë²ˆí˜¸ ë³´ê¸°">ğŸ‘</button>
          </div>
        </div>
        <div class="input-group">
          <label for="geminiKey">Gemini API Key</label>
          <div class="input-wrapper">
            <input type="password" id="geminiKey" placeholder="AIza... (Google AI Studioì—ì„œ ë¬´ë£Œ ë°œê¸‰ ê°€ëŠ¥)">
            <button type="button" class="toggle-visibility" data-target="geminiKey" title="ë¹„ë°€ë²ˆí˜¸ ë³´ê¸°">ğŸ‘</button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" id="cancelSettings">ì·¨ì†Œ</button>
        <button class="btn btn-primary" id="saveSettings">ì €ì¥</button>
      </div>
    </div>
  </div>

  <script>
    // DOM Elements
    const dateRangeSelect = document.getElementById('dateRange');
    const tabAll = document.getElementById('tabAll');
    const tabPending = document.getElementById('tabPending');
    const emptyState = document.getElementById('emptyState');
    const commentList = document.getElementById('commentList');
    const openSettingsBtn = document.getElementById('openSettings');
    const settingsModal = document.getElementById('settingsModal');
    const cancelSettingsBtn = document.getElementById('cancelSettings');
    const saveSettingsBtn = document.getElementById('saveSettings');
    const figmaTokenInput = document.getElementById('figmaToken');
    const geminiKeyInput = document.getElementById('geminiKey');
    const figmaFileUrlInput = document.getElementById('figmaFileUrl');
    const toast = document.getElementById('toast');
    const settingsStatus = document.getElementById('settingsStatus');
    const toggleButtons = document.querySelectorAll('.toggle-visibility');

    // Toast ì•Œë¦¼ í‘œì‹œ í•¨ìˆ˜
    function showToast(message, type = 'default') {
      toast.textContent = message;
      toast.className = 'toast show ' + type;
      setTimeout(() => {
        toast.className = 'toast';
      }, 3000);
    }

    // ì„¤ì • ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateSettingsStatus(hasSettings) {
      if (hasSettings) {
        settingsStatus.textContent = 'ì„¤ì •ë¨ âœ“';
        settingsStatus.className = 'settings-status configured';
      } else {
        settingsStatus.textContent = 'ë¯¸ì„¤ì •';
        settingsStatus.className = 'settings-status not-configured';
      }
    }

    // Figma URLì—ì„œ fileKey ì¶”ì¶œ
    // ì§€ì› í˜•ì‹: /file/{key}/..., /design/{key}/..., /board/{key}/...
    function extractFileKeyFromUrl(url) {
      const match = url.match(/figma\.com\/(file|design|board)\/([a-zA-Z0-9]+)/);
      return match ? match[2] : null;
    }

    // Tab switching
    let currentFilter = 'all'; // 'all' | 'pending'
    let allClassifiedComments = []; // ë¶„ë¥˜ëœ ì½”ë©˜íŠ¸ ì „ì²´ ì €ì¥
    let currentCheckedStates = {}; // ì²´í¬ ìƒíƒœ
    let frameSummaries = {}; // í”„ë ˆì„ë³„ AI ìš”ì•½ ì¹´ë“œ ë°ì´í„°

    tabAll.addEventListener('click', () => {
      tabAll.classList.add('active');
      tabPending.classList.remove('active');
      currentFilter = 'all';
      applyFilter();
    });

    tabPending.addEventListener('click', () => {
      tabPending.classList.add('active');
      tabAll.classList.remove('active');
      currentFilter = 'pending';
      applyFilter();
    });

    // Date range change
    dateRangeSelect.addEventListener('change', (e) => {
      const range = e.target.value;
      parent.postMessage({ pluginMessage: { type: 'date-range-changed', range } }, '*');
    });

    // Password visibility toggle
    toggleButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const targetId = btn.getAttribute('data-target');
        const input = document.getElementById(targetId);
        if (input.type === 'password') {
          input.type = 'text';
          btn.textContent = 'ğŸ™ˆ';
          btn.title = 'ë¹„ë°€ë²ˆí˜¸ ìˆ¨ê¸°ê¸°';
        } else {
          input.type = 'password';
          btn.textContent = 'ğŸ‘';
          btn.title = 'ë¹„ë°€ë²ˆí˜¸ ë³´ê¸°';
        }
      });
    });

    // Settings modal
    openSettingsBtn.addEventListener('click', () => {
      settingsModal.classList.add('show');
    });

    cancelSettingsBtn.addEventListener('click', () => {
      settingsModal.classList.remove('show');
    });

    saveSettingsBtn.addEventListener('click', () => {
      const figmaToken = figmaTokenInput.value.trim();
      const geminiKey = geminiKeyInput.value.trim();
      const fileUrl = figmaFileUrlInput.value.trim();

      // Figma URLì—ì„œ fileKey ì¶”ì¶œ
      if (fileUrl) {
        const extractedKey = extractFileKeyFromUrl(fileUrl);
        if (extractedKey) {
          parent.postMessage({
            pluginMessage: { type: 'save-file-key', fileKey: extractedKey }
          }, '*');
          window.fileKey = extractedKey;
        } else {
          showToast('Figma URL í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.', 'error');
          return;
        }
      }

      parent.postMessage({
        pluginMessage: {
          type: 'save-api-keys',
          figmaToken,
          geminiKey
        }
      }, '*');
      settingsModal.classList.remove('show');
    });

    // Close modal when clicking overlay
    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) {
        settingsModal.classList.remove('show');
      }
    });

    // Receive messages from plugin code
    window.onmessage = (event) => {
      const message = event.data.pluginMessage;
      if (!message) return;

      switch (message.type) {
        case 'load-settings':
          // Pre-fill saved API keys
          if (message.figmaToken) figmaTokenInput.value = message.figmaToken;
          if (message.geminiKey) geminiKeyInput.value = message.geminiKey;
          // ì„¤ì • ìƒíƒœ ì—…ë°ì´íŠ¸
          updateSettingsStatus(message.hasSettings);
          break;

        case 'settings-saved':
          // ì €ì¥ ê²°ê³¼ Toast í‘œì‹œ
          showToast(message.message, message.success ? 'success' : 'error');
          if (message.success) {
            updateSettingsStatus(true);
          }
          break;

        case 'file-info':
          // íŒŒì¼ ì •ë³´ ì €ì¥
          window.fileKey = message.fileKey;
          window.fileName = message.fileName;
          console.log('ğŸ“ íŒŒì¼ ì •ë³´:', message.fileName, message.fileKey);
          // fileKeyê°€ ì—†ìœ¼ë©´ ì„¤ì • ëª¨ë‹¬ ìë™ ì˜¤í”ˆ
          if (!message.fileKey) {
            console.log('âš ï¸ fileKeyê°€ ì—†ìŠµë‹ˆë‹¤. ì„¤ì •ì—ì„œ Figma íŒŒì¼ URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
          }
          break;

        case 'file-key-saved':
          window.fileKey = message.fileKey;
          showToast('íŒŒì¼ í‚¤ ì €ì¥ ì™„ë£Œ!', 'success');
          break;

        case 'fetch-comments-request':
          // code.tsì—ì„œ ìš”ì²­ì´ ì˜¤ë©´ ì‹¤ì œ API í˜¸ì¶œ ìˆ˜í–‰
          fetchComments(message.fileKey, message.figmaToken, message.range, message.lastCheckTime);
          break;

        case 'fetch-error':
          // ì—ëŸ¬ í‘œì‹œ
          showToast(message.error, 'error');
          updateEmptyState('error', message.error);
          break;

        case 'comments-loaded':
          console.log(`ğŸ“‹ UIì—ì„œ ${message.count}ê°œ ì½”ë©˜íŠ¸ ìˆ˜ì‹ `);
          currentCheckedStates = message.checkedStates || {};
          if (message.count === 0) {
            updateEmptyState('empty', 'í•´ë‹¹ ê¸°ê°„ì— ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
          } else {
            classifyAndRenderComments(message.comments);
          }
          break;
      }
    };

    // ===== Phase 1-2: Figma REST API ì½”ë©˜íŠ¸ ì¡°íšŒ =====

    // ê¸°ê°„ í•„í„° ê³„ì‚° í•¨ìˆ˜
    function getDateFilter(range, lastCheckTime) {
      const now = new Date();
      let sinceDate;

      switch (range) {
        case '24h':
          sinceDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
          break;
        case '3d':
          sinceDate = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000);
          break;
        case '1w':
          sinceDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          break;
        case 'last':
          sinceDate = lastCheckTime ? new Date(lastCheckTime) : new Date(now.getTime() - 24 * 60 * 60 * 1000);
          break;
        default:
          sinceDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
      }

      return sinceDate.toISOString();
    }

    // ì½”ë©˜íŠ¸ ì¡°íšŒ í•¨ìˆ˜
    async function fetchComments(fileKey, figmaToken, range, lastCheckTime) {
      // ë¡œë”© ìƒíƒœ í‘œì‹œ
      updateEmptyState('loading', 'ì½”ë©˜íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');

      try {
        const response = await fetch(
          `https://api.figma.com/v1/files/${fileKey}/comments`,
          {
            method: 'GET',
            headers: {
              'X-Figma-Token': figmaToken
            }
          }
        );

        if (!response.ok) {
          let errorMessage = 'ì½”ë©˜íŠ¸ë¥¼ ê°€ì ¸ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
          if (response.status === 403) {
            errorMessage = 'API í† í°ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì„¤ì •í•´ì£¼ì„¸ìš”.';
          } else if (response.status === 404) {
            errorMessage = 'íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
          }
          throw new Error(errorMessage);
        }

        const data = await response.json();
        const allComments = data.comments || [];

        // ê¸°ê°„ í•„í„°ë§
        const sinceDate = getDateFilter(range, lastCheckTime);
        const filteredComments = allComments.filter(comment => {
          return new Date(comment.created_at) >= new Date(sinceDate);
        });

        console.log(`ğŸ” ì „ì²´ ${allComments.length}ê°œ ì¤‘ ${filteredComments.length}ê°œ í•„í„°ë¨ (${range})`);

        // code.tsì— ê²°ê³¼ ì „ë‹¬
        parent.postMessage({
          pluginMessage: {
            type: 'comments-fetched',
            comments: filteredComments
          }
        }, '*');

        // ë¡œë”© ì™„ë£Œ Toast
        showToast(`${filteredComments.length}ê°œ ì½”ë©˜íŠ¸ ë¡œë“œ ì™„ë£Œ`, 'success');

      } catch (error) {
        console.error('âŒ ì½”ë©˜íŠ¸ ì¡°íšŒ ì‹¤íŒ¨:', error);
        parent.postMessage({
          pluginMessage: {
            type: 'comments-fetch-error',
            error: error.message
          }
        }, '*');
      }
    }

    // Empty State ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateEmptyState(state, message) {
      const emptyIcon = emptyState.querySelector('.empty-icon');
      const emptyTitle = emptyState.querySelector('.empty-title');
      const emptyDesc = emptyState.querySelector('.empty-desc');

      switch (state) {
        case 'loading':
          emptyIcon.innerHTML = `
            <svg class="spinner" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 12a9 9 0 11-6.219-8.56"></path>
            </svg>
          `;
          emptyTitle.textContent = message || 'ë¡œë”© ì¤‘...';
          emptyDesc.textContent = '';
          break;
        case 'error':
          emptyIcon.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#e53935" stroke-width="2">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="15" y1="9" x2="9" y2="15"></line>
              <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
          `;
          emptyTitle.textContent = 'ì˜¤ë¥˜ ë°œìƒ';
          emptyDesc.textContent = message || '';
          break;
        case 'empty':
          emptyIcon.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
          `;
          emptyTitle.textContent = message || 'ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤';
          emptyDesc.textContent = 'ê¸°ê°„ì„ ë³€ê²½í•´ë³´ì„¸ìš”';
          break;
        default:
          emptyIcon.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
          `;
          emptyTitle.textContent = 'ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤';
          emptyDesc.textContent = 'ê¸°ê°„ì„ ì„ íƒí•˜ê³  API í‚¤ë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”';
      }
    }

    // ===== Gemini API í†µì‹  í•¨ìˆ˜ (429 ìë™ ì¬ì‹œë„ í¬í•¨) =====

    async function callGeminiAPI(geminiKey, promptText, maxRetries = 3) {
      const GEMINI_MODEL = 'gemini-2.0-flash';
      const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${geminiKey}`;

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{ parts: [{ text: promptText }] }],
            generationConfig: {
              temperature: 0.2,
              maxOutputTokens: 4096,
              responseMimeType: 'application/json'
            }
          })
        });

        if (response.ok) {
          const data = await response.json();
          const resultText = data.candidates?.[0]?.content?.parts?.[0]?.text;
          if (!resultText) throw new Error('Gemini ì‘ë‹µì—ì„œ ê²°ê³¼ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          return JSON.parse(resultText);
        }

        if (response.status === 429 && attempt < maxRetries) {
          const backoffSec = 5 * Math.pow(2, attempt); // 5ì´ˆ, 10ì´ˆ, 20ì´ˆ
          console.warn(`â³ 429 Rate Limit â†’ ${backoffSec}ì´ˆ í›„ ì¬ì‹œë„ (${attempt + 1}/${maxRetries})`);
          await sleep(backoffSec * 1000);
          continue;
        }

        let errorMessage = 'Gemini API í˜¸ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
        if (response.status === 400) errorMessage = 'Gemini API í‚¤ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.';
        else if (response.status === 429) errorMessage = `API í˜¸ì¶œ í•œë„ ì´ˆê³¼. ${maxRetries}íšŒ ì¬ì‹œë„ ì‹¤íŒ¨.`;
        throw new Error(errorMessage);
      }
    }

    // ===== One-Shot í”„ë ˆì„ë³„ í†µí•© ì²˜ë¦¬ (ë¶„ë¥˜ + ìš”ì•½) =====

    const FRAME_DELAY_MS = 1000; // í”„ë ˆì„ ê°„ 1ì´ˆ ë”œë ˆì´

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function classifyAndRenderComments(comments) {
      const geminiKey = geminiKeyInput.value.trim();

      // API í‚¤ ì—†ìœ¼ë©´ ë¶„ë¥˜ ì—†ì´ ë°”ë¡œ ë Œë”ë§
      if (!geminiKey) {
        allClassifiedComments = comments.map(comment => ({
          ...comment,
          category: 'discussion',
          priority: 'normal',
          summary: comment.message.substring(0, 30),
          checked: currentCheckedStates[comment.id] || false
        }));
        renderCommentList(allClassifiedComments);
        showToast('Gemini API í‚¤ê°€ ì—†ì–´ ë¶„ë¥˜ ì—†ì´ í‘œì‹œí•©ë‹ˆë‹¤.', 'error');
        return;
      }

      // 1ë‹¨ê³„: ë¡œì»¬ í”„ë ˆì„ë³„ ê·¸ë£¹í•‘ (API í˜¸ì¶œ ì „)
      const groups = {};
      comments.forEach(c => {
        const key = c.frameName || 'ê¸°íƒ€';
        if (!groups[key]) groups[key] = [];
        groups[key].push(c);
      });

      const frameNames = Object.keys(groups);
      console.log(`ğŸš€ ${frameNames.length}ê°œ í”„ë ˆì„ í†µí•© ì²˜ë¦¬ ì‹œì‘ (ë¶„ë¥˜+ìš”ì•½ ë™ì‹œ)`);

      // ë¨¼ì € ê¸°ë³¸ê°’ìœ¼ë¡œ ì „ì²´ ë Œë”ë§ (ë¡œë”© ìƒíƒœ í‘œì‹œ)
      allClassifiedComments = comments.map(comment => ({
        ...comment,
        category: 'discussion',
        priority: 'normal',
        summary: comment.message.substring(0, 30),
        checked: currentCheckedStates[comment.id] || false
      }));
      frameSummaries = {};
      renderCommentList(allClassifiedComments);
      updateEmptyState('loading', `AI ë¶„ì„ ì¤‘... (0/${frameNames.length} í”„ë ˆì„)`);

      // 2ë‹¨ê³„: í”„ë ˆì„ë³„ One-Shot API í˜¸ì¶œ
      let failedFrames = 0;

      for (let i = 0; i < frameNames.length; i++) {
        const frameName = frameNames[i];
        const frameComments = groups[frameName];

        updateEmptyState('loading', `AI ë¶„ì„ ì¤‘... (${i + 1}/${frameNames.length} í”„ë ˆì„: ${frameName})`);

        // ì½”ë©˜íŠ¸ 1ê°œë©´ API í˜¸ì¶œ ë¶ˆí•„ìš”
        if (frameComments.length < 2) {
          const c = frameComments[0];
          // ë¶„ë¥˜: ê¸°ë³¸ê°’ ìœ ì§€
          frameSummaries[frameName] = {
            summary: {
              title: c.message.substring(0, 15),
              status: 'Open',
              issues: [],
              decisions: []
            },
            classifiedComments: [{
              id: c.id,
              category: 'discussion',
              priority: 'normal',
              summary: c.message.substring(0, 20)
            }]
          };
          applyFrameResult(frameName, frameSummaries[frameName], frameComments);
          updateSummaryCard(frameName);
          continue;
        }

        try {
          const prompt = buildOneShotPrompt(frameName, frameComments);
          const result = await callGeminiAPI(geminiKey, prompt);
          frameSummaries[frameName] = result;
          applyFrameResult(frameName, result, frameComments);
          updateSummaryCard(frameName);
          console.log(`  âœ… "${frameName}" ì™„ë£Œ (${frameComments.length}ê°œ ì½”ë©˜íŠ¸)`);
        } catch (error) {
          console.warn(`  âš ï¸ "${frameName}" ì‹¤íŒ¨:`, error.message);
          failedFrames++;
          frameSummaries[frameName] = {
            summary: { title: 'ë¶„ì„ ì‹¤íŒ¨', status: 'Error', issues: [], decisions: [] },
            classifiedComments: []
          };
          updateSummaryCard(frameName);
        }

        // ë§ˆì§€ë§‰ í”„ë ˆì„ì´ ì•„ë‹ˆë©´ ë”œë ˆì´
        if (i < frameNames.length - 1) {
          await sleep(FRAME_DELAY_MS);
        }
      }

      // ìµœì¢… ë Œë”ë§
      renderCommentList(allClassifiedComments);

      const successFrames = frameNames.length - failedFrames;
      if (failedFrames === 0) {
        showToast(`${frameNames.length}ê°œ í”„ë ˆì„ ë¶„ì„ ì™„ë£Œ`, 'success');
      } else {
        showToast(`${successFrames}/${frameNames.length} í”„ë ˆì„ ì„±ê³µ, ${failedFrames}ê°œ ì‹¤íŒ¨`, 'error');
      }
    }

    // í”„ë ˆì„ ê²°ê³¼ë¥¼ allClassifiedCommentsì— ë°˜ì˜
    function applyFrameResult(frameName, result, frameComments) {
      const classified = result.classifiedComments || [];
      frameComments.forEach(comment => {
        const match = classified.find(c => c.id === comment.id);
        if (match) {
          const idx = allClassifiedComments.findIndex(c => c.id === comment.id);
          if (idx !== -1) {
            allClassifiedComments[idx].category = match.category || 'discussion';
            allClassifiedComments[idx].priority = match.priority || 'normal';
            allClassifiedComments[idx].summary = match.summary || comment.message.substring(0, 20);
          }
        }
      });
    }

    function buildOneShotPrompt(frameName, comments) {
      const commentList = comments.map(c =>
        `{"id":"${c.id}","user":"${c.user?.handle || 'unknown'}","msg":"${c.message.replace(/"/g, '\\"').replace(/\n/g, ' ').substring(0, 300)}"}`
      ).join(',\n');

      return `ì•„ë˜ëŠ” Figma í”„ë ˆì„ "${frameName}"ì— ë‹¬ë¦° ì½”ë©˜íŠ¸ ëŒ€í™”ì…ë‹ˆë‹¤.
ë‘ ê°€ì§€ë¥¼ ë™ì‹œì— ë¶„ì„í•´ì£¼ì„¸ìš”:

[ì½”ë©˜íŠ¸ ëª©ë¡]
[${commentList}]

=== ë¶„ì„ ìš”ì²­ ===
1) summary: ì´ í”„ë ˆì„ì˜ ëŒ€í™”ë¥¼ í•œêµ­ì–´ë¡œ ìš”ì•½
2) classifiedComments: ê° ì½”ë©˜íŠ¸ë¥¼ ë¶„ë¥˜

JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µ:
{
  "summary": {
    "title": "í•µì‹¬ ì£¼ì œ 15ìì´ë‚´",
    "status": "Open ë˜ëŠ” Resolved",
    "issues": ["ì£¼ìš” ì´ìŠˆ (í•œêµ­ì–´)"],
    "decisions": ["ê²°ì •/í•  ì¼ (í•œêµ­ì–´)"]
  },
  "classifiedComments": [
    {"id":"ì›ë³¸id","category":"bug|change_request|question|discussion","priority":"urgent|normal","summary":"í•œêµ­ì–´ í•œì¤„ìš”ì•½ 20ìì´ë‚´"}
  ]
}`;
    }

    function updateSummaryCard(frameName) {
      const card = document.querySelector(`.summary-card[data-frame="${CSS.escape(frameName)}"]`);
      if (!card) return;
      const data = frameSummaries[frameName]?.summary;
      if (!data) return;

      const statusColor = data.status === 'Resolved' ? '#4caf50' : '#fb8c00';
      const statusLabel = data.status === 'Resolved' ? 'âœ… í•´ê²°ë¨' : 'ğŸ”„ ì§„í–‰ ì¤‘';

      let html = `<div class="summary-card-title">ğŸ’¡ ${data.title} <span style="font-size:10px;color:${statusColor};margin-left:6px;">${statusLabel}</span></div>`;
      if (data.issues?.length) html += data.issues.map(i => `<div class="summary-card-section"><span class="section-icon">ğŸ“Œ</span>${i}</div>`).join('');
      if (data.decisions?.length) html += data.decisions.map(d => `<div class="summary-card-section"><span class="section-icon">âœ…</span>${d}</div>`).join('');

      card.innerHTML = html;
    }

    // ===== Phase 1-4: UI ë Œë”ë§ =====

    const CATEGORY_MAP = {
      bug: { label: 'ë²„ê·¸', cssClass: 'tag-bug', icon: 'ğŸ”´' },
      change_request: { label: 'ìˆ˜ì • ìš”ì²­', cssClass: 'tag-change', icon: 'ğŸŸ ' },
      question: { label: 'ì§ˆë¬¸', cssClass: 'tag-question', icon: 'ğŸ”µ' },
      discussion: { label: 'ë…¼ì˜', cssClass: 'tag-feedback', icon: 'âšª' }
    };

    function renderCommentList(comments) {
      // í•„í„° ì ìš©
      let filtered = comments;
      if (currentFilter === 'pending') {
        filtered = comments.filter(c => !c.checked);
      }

      // í”„ë ˆì„ë³„ ê·¸ë£¹í•‘
      const groups = {};
      filtered.forEach(comment => {
        const key = comment.frameName || 'ê¸°íƒ€';
        if (!groups[key]) groups[key] = [];
        groups[key].push(comment);
      });

      // ì½”ë©˜íŠ¸ ìˆ˜ ê¸°ì¤€ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
      const sortedKeys = Object.keys(groups).sort((a, b) => groups[b].length - groups[a].length);

      if (sortedKeys.length === 0) {
        emptyState.style.display = 'flex';
        commentList.style.display = 'none';
        updateEmptyState('empty', currentFilter === 'pending' ? 'ë¯¸ì™„ë£Œ ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤' : 'í•´ë‹¹ ê¸°ê°„ì— ì½”ë©˜íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
        updateTabCounts(comments);
        return;
      }

      let html = '';
      sortedKeys.forEach(frameName => {
        const groupComments = groups[frameName];

        // ê·¸ë£¹ í—¤ë”
        const categoryCounts = {};
        groupComments.forEach(c => {
          categoryCounts[c.category] = (categoryCounts[c.category] || 0) + 1;
        });
        const categoryBadges = Object.entries(categoryCounts)
          .map(([cat, count]) => `${CATEGORY_MAP[cat]?.icon || 'âšª'} ${count}`)
          .join(' ');

        html += `<div class="comment-group">`;
        html += `<div class="group-header">
          <span class="group-icon">ğŸ“</span>
          <span>${frameName}</span>
          <span style="margin-left:auto; font-size:10px; color:#999; font-weight:400;">${categoryBadges}</span>
        </div>`;

        // AI ìš”ì•½ ì¹´ë“œ (ë¡œë”© ë˜ëŠ” ë°ì´í„°)
        const frameData = frameSummaries[frameName];
        const summary = frameData?.summary;
        if (summary) {
          const statusColor = summary.status === 'Resolved' ? '#4caf50' : '#fb8c00';
          const statusLabel = summary.status === 'Resolved' ? 'âœ… í•´ê²°ë¨' : 'ğŸ”„ ì§„í–‰ ì¤‘';
          html += `<div class="summary-card" data-frame="${frameName}">`;
          html += `<div class="summary-card-title">ğŸ’¡ ${summary.title} <span style="font-size:10px;color:${statusColor};margin-left:6px;">${statusLabel}</span></div>`;
          if (summary.issues?.length) html += summary.issues.map(i => `<div class="summary-card-section"><span class="section-icon">ğŸ“Œ</span>${i}</div>`).join('');
          if (summary.decisions?.length) html += summary.decisions.map(d => `<div class="summary-card-section"><span class="section-icon">âœ…</span>${d}</div>`).join('');
          html += `</div>`;
        } else {
          html += `<div class="summary-card" data-frame="${frameName}"><span class="summary-card-loading">ğŸ’¡ ìš”ì•½ ìƒì„± ì¤‘...</span></div>`;
        }

        // ì•„ì½”ë””ì–¸ í† ê¸€
        html += `<button class="group-toggle" data-frame="${frameName}">
          <span class="toggle-arrow">â–¶</span> ì½”ë©˜íŠ¸ ${groupComments.length}ê±´ ë³´ê¸°
        </button>`;

        // ì½”ë©˜íŠ¸ ëª©ë¡ (ê¸°ë³¸ ì ‘íŒ ìƒíƒœ)
        html += `<div class="comment-items-container collapsed" data-frame-items="${frameName}">`;

        // ìš°ì„ ìˆœìœ„ urgent ë¨¼ì €, ê·¸ ë‹¤ìŒ ìµœì‹ ìˆœ
        const sorted = [...groupComments].sort((a, b) => {
          if (a.priority === 'urgent' && b.priority !== 'urgent') return -1;
          if (b.priority === 'urgent' && a.priority !== 'urgent') return 1;
          return new Date(b.created_at) - new Date(a.created_at);
        });

        sorted.forEach(comment => {
          const cat = CATEGORY_MAP[comment.category] || CATEGORY_MAP.discussion;
          const urgentBadge = comment.priority === 'urgent'
            ? '<span style="background:#ffebee;color:#e53935;padding:1px 5px;border-radius:3px;font-size:9px;font-weight:600;margin-left:4px;">ê¸´ê¸‰</span>'
            : '';
          const nodeId = comment.resolvedNodeId || comment.client_meta?.node_id || '';
          const checkedAttr = comment.checked ? 'checked' : '';
          const checkedStyle = comment.checked ? 'opacity: 0.5;' : '';

          html += `
            <div class="comment-item" data-node-id="${nodeId}" data-comment-id="${comment.id}" style="${checkedStyle}">
              <input type="checkbox" class="comment-checkbox" data-id="${comment.id}" ${checkedAttr}>
              <div class="comment-content">
                <span class="comment-tag ${cat.cssClass}">${cat.label}</span>${urgentBadge}
                <p class="comment-summary">${comment.summary || comment.message.substring(0, 30)}</p>
                <p class="comment-meta">@${comment.user?.handle || 'unknown'} Â· ${formatRelativeTime(comment.created_at)}</p>
              </div>
            </div>`;
        });

        html += `</div>`; // comment-items-container
        html += `</div>`; // comment-group
      });

      commentList.innerHTML = html;
      emptyState.style.display = 'none';
      commentList.style.display = 'block';

      updateTabCounts(comments);
      attachCommentEvents();
    }

    function attachCommentEvents() {
      // ì•„ì½”ë””ì–¸ í† ê¸€
      commentList.querySelectorAll('.group-toggle').forEach(btn => {
        btn.addEventListener('click', () => {
          const frameName = btn.getAttribute('data-frame');
          const container = commentList.querySelector(`[data-frame-items="${frameName}"]`);
          const arrow = btn.querySelector('.toggle-arrow');
          if (!container) return;

          if (container.classList.contains('collapsed')) {
            container.classList.remove('collapsed');
            container.style.maxHeight = container.scrollHeight + 'px';
            arrow.classList.add('open');
            btn.innerHTML = `<span class="toggle-arrow open">â–¶</span> ì½”ë©˜íŠ¸ ì ‘ê¸°`;
          } else {
            container.classList.add('collapsed');
            container.style.maxHeight = '0';
            arrow.classList.remove('open');
            const count = container.querySelectorAll('.comment-item').length;
            btn.innerHTML = `<span class="toggle-arrow">â–¶</span> ì½”ë©˜íŠ¸ ${count}ê±´ ë³´ê¸°`;
          }
        });
      });

      // ì²´í¬ë°•ìŠ¤ ì´ë²¤íŠ¸
      commentList.querySelectorAll('.comment-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
          e.stopPropagation();
          const commentId = e.target.getAttribute('data-id');
          const checked = e.target.checked;

          // UI ìƒíƒœ ì—…ë°ì´íŠ¸
          const item = e.target.closest('.comment-item');
          item.style.opacity = checked ? '0.5' : '1';

          // ë°ì´í„° ì—…ë°ì´íŠ¸
          currentCheckedStates[commentId] = checked;
          const comment = allClassifiedComments.find(c => c.id === commentId);
          if (comment) comment.checked = checked;

          // code.tsì— ì €ì¥ ìš”ì²­
          parent.postMessage({
            pluginMessage: { type: 'save-check-state', commentId, checked }
          }, '*');

          updateTabCounts(allClassifiedComments);

          // ë¯¸ì™„ë£Œ í•„í„° ì¤‘ì´ë©´ ì™„ë£Œëœ í•­ëª© ì œê±°
          if (currentFilter === 'pending' && checked) {
            setTimeout(() => renderCommentList(allClassifiedComments), 300);
          }
        });
      });

      // ì½”ë©˜íŠ¸ í´ë¦­ â†’ ë”¥ë§í¬
      commentList.querySelectorAll('.comment-item').forEach(item => {
        item.addEventListener('click', (e) => {
          if (e.target.type === 'checkbox') return; // ì²´í¬ë°•ìŠ¤ í´ë¦­ì€ ì œì™¸
          const nodeId = item.getAttribute('data-node-id');
          if (nodeId) {
            parent.postMessage({
              pluginMessage: { type: 'zoom-to-node', nodeId }
            }, '*');
          }
        });
      });
    }

    function formatRelativeTime(dateStr) {
      const diff = Date.now() - new Date(dateStr).getTime();
      const minutes = Math.floor(diff / 60000);
      if (minutes < 1) return 'ë°©ê¸ˆ';
      if (minutes < 60) return `${minutes}ë¶„ ì „`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}ì‹œê°„ ì „`;
      const days = Math.floor(hours / 24);
      if (days < 7) return `${days}ì¼ ì „`;
      return new Date(dateStr).toLocaleDateString('ko-KR');
    }

    function updateTabCounts(comments) {
      const total = comments.length;
      const pending = comments.filter(c => !c.checked).length;
      tabAll.querySelector('.tab-count').textContent = total;
      tabPending.querySelector('.tab-count').textContent = pending;
    }

    function applyFilter() {
      if (allClassifiedComments.length > 0) {
        renderCommentList(allClassifiedComments);
      }
    }
  </script>
</body>

</html>